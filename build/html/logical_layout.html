

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>10. stingray Developer’s Guide &mdash; The Stingray Schema-Based File Reader</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="The Stingray Schema-Based File Reader" href="index.html" />
    <link rel="next" title="11. Data Quality Assurance Applications" href="demo/index.html" />
    <link rel="prev" title="9. COBOL Loader Module – Parse COBOL Source to Load a Schema" href="cobol_loader.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="demo/index.html" title="11. Data Quality Assurance Applications"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cobol_loader.html" title="9. COBOL Loader Module – Parse COBOL Source to Load a Schema"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">The Stingray Schema-Based File Reader</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="stingray-developer-s-guide">
<span id="logical-layout"></span><h1>10. <tt class="docutils literal"><span class="pre">stingray</span></tt> Developer&#8217;s Guide<a class="headerlink" href="#stingray-developer-s-guide" title="Permalink to this headline">¶</a></h1>
<p>Or, &#8220;How do I use <tt class="docutils literal"><span class="pre">stingray</span></tt> to work with a schema?&#8221;</p>
<p>We use Stingray to build applications because
we have a fundamental question about a file and an application.</p>
<blockquote>
<div><strong>How do we validate that a file and an application use the same schema?</strong></div></blockquote>
<p>Or</p>
<blockquote>
<div><strong>How do we validate the conceptual schema?</strong></div></blockquote>
<p>There are two sides to this: File and Application.</p>
<ul class="simple">
<li>Given a data file, how do we bind schema information to that file?</li>
<li>What schema does an application require?</li>
</ul>
<p>We do need to note the following.</p>
<blockquote>
<div><strong>If it was simple, we wouldn&#8217;t need this package, would we?</strong></div></blockquote>
<p>As noted in <a class="reference internal" href="introduction.html#intro"><em>Introduction</em></a>, we have three levels of schema that need to be bound to a file.</p>
<ul class="simple">
<li><strong>Physical Format</strong>.  We can make this transparent to our applications.
See <a class="reference internal" href="workbook.html#workbook"><em>Workbook Module &#8211; Uniform Wrapper on All Workbooks</em></a> and <a class="reference internal" href="cobol.html#cobol"><em>COBOL Package &#8211; Extend Schema to Handle EBCDIC</em></a> for details.</li>
<li><strong>Logical Layout</strong>.  This is how an application program will make use
of the data found in a file.  Logical layout can be embedded in a file
or separate.  Our applications and files both need to agree on a logical
layout.</li>
<li><strong>Conceptual Content</strong>.
A single conceptual schema may be implemented by a number of physical
formats and logical layouts.
An application should be able to tolerate variability in the logical
layout as long is it matches the expected <strong>conceptual</strong> schema.</li>
</ul>
<p>We&#8217;ll tackle this in several pieces.</p>
<ul class="simple">
<li><strong>File Schema</strong>.  <a class="reference internal" href="#binding-a-schema-to-a-file">Binding a Schema to a File</a> describes some preliminary
operational steps that make Stingray work more simply and reliably.</li>
<li><strong>Application Schema</strong>.  <a class="reference internal" href="#binding-a-schema-to-an-application">Binding a Schema to an Application</a> and <a class="reference internal" href="#schema-version-numbering">Schema Version Numbering</a></li>
<li><strong>Processing</strong>.  <a class="reference internal" href="#data-attribute-mapping-using-a-schema">Data Attribute Mapping &#8211; Using a Schema</a> and <a class="reference internal" href="#data-transformation">Data Transformation</a></li>
<li><strong>Application Design Patterns</strong>.
We can then dig into Stingray application programming in <cite>stingray Application Design</cite>.</li>
</ul>
<p>We&#8217;ll look at some demonstration programs in <a class="reference internal" href="demo/index.html#demo"><em>Data Quality Assurance Applications</em></a>.</p>
<div class="section" id="binding-a-schema-to-a-file">
<h2>10.1. Binding a Schema to a File<a class="headerlink" href="#binding-a-schema-to-a-file" title="Permalink to this headline">¶</a></h2>
<p>We&#8217;re only going to bind two levels of schema to a file.  The conceptual schema
would require some kind of formal ontology, something that&#8217;s rarely available.</p>
<p><strong>Logical Layout</strong>.
A workbook in a well-known physical format has two ways to bind logial layout to data.  Our <a class="reference internal" href="sheet.html#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a> subclass hierarchy, along with the various <a class="reference internal" href="schema_loader.html#module-schema.loader" title="schema.loader"><tt class="xref py py-mod docutils literal"><span class="pre">schema.loader</span></tt></a> components will to handle this.</p>
<ul class="simple">
<li><strong>Embedded</strong>.  This is column titles within the sheet.  Or
any variation on that theme.
In spite of the vagaries, this works out well,
is quite popular and can be managed by building different schema loaders.</li>
<li><strong>External</strong>.  This is a separate sheet or separate file.
This  requires
some data management discipline to be sure that the schema and file match
up properly.  Naming conventions and directory structures are
<em>essential</em> for working with external schema.</li>
</ul>
<p><strong>Physical Format</strong>.  Generally, a file name provides a hint as to the physical file format.
<tt class="file docutils literal"><span class="pre">.csv</span></tt>, <tt class="file docutils literal"><span class="pre">.xls</span></tt>, <tt class="file docutils literal"><span class="pre">.xlsx</span></tt>, <tt class="file docutils literal"><span class="pre">.xlsm</span></tt>, <tt class="file docutils literal"><span class="pre">.ods</span></tt> describe the physical format.   Our <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a>, <a class="reference internal" href="sheet.html#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a>, and
<a class="reference internal" href="workbook.html#workbook.Workbook" title="workbook.Workbook"><tt class="xref py py-class docutils literal"><span class="pre">workbook.Workbook</span></tt></a> handles this nicely.</p>
<p>For fixed-format files, however,
there&#8217;s no <em>simple</em> extension that describes the physical layout.
Further, fixed format files combine logical layout and physical format into
a single schema description.</p>
<p>For fixed format files, the following conventions help
bind a file to its schema.</p>
<ul class="simple">
<li>The data file extension is the base name of a schema file.
<tt class="file docutils literal"><span class="pre">mydata.someschema</span></tt>.</li>
<li>Schema files must be be either a DDE file or a
workbook in a well-known format.
<tt class="samp docutils literal"><span class="pre">someschema.cob</span></tt> or <tt class="file docutils literal"><span class="pre">someschema.xlsx</span></tt>.</li>
</ul>
<p>A DDE file is in COBOL notation, and defines the field name, type and size.  The offsets are deduced from the declarations using COBOL language semantics.</p>
<p>A workbook with a schema must adhere to a few conventions to be usable.
If the workbook uses multiple sheets, the standard sheet name <tt class="docutils literal"><span class="pre">&quot;Schema&quot;</span></tt>
defines the appropriate sheet.
There must be an internal meta-schema on line one of the sheet
that provides the expected column names.
The column names &#8220;name&#8221;, &#8220;offset&#8221;, &#8220;size&#8221;, &#8220;type&#8221;.  Only &#8220;name&#8221; is required
in general.
For fixed format files, &#8220;offset&#8221;, &#8220;size&#8221; and &#8220;type&#8221; are also required.
Additional columns are allowed, but will be ignored.
Type definitions are &#8220;text&#8221;, &#8220;number&#8221;, &#8220;date&#8221; and &#8220;boolean&#8221;.</p>
<p><strong>Examples</strong>.  We might see the following file names.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">september_2001</span><span class="o">.</span><span class="n">exchange_1</span>
<span class="n">november_2011</span><span class="o">.</span><span class="n">some_dde_name</span>
<span class="n">october_2011</span><span class="o">.</span><span class="n">some_dde_name</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">september_2001.exchange_1</span></tt> file is a fixed format file
which requires the <tt class="docutils literal"><span class="pre">exchange_1.xls</span></tt> metadata workbook.</p>
<p>The <tt class="docutils literal"><span class="pre">november_2011.some_dde_name</span></tt> and <tt class="docutils literal"><span class="pre">october_2011.some_dde_name</span></tt> files
are fixed format files which require the <tt class="docutils literal"><span class="pre">some_dde_name.cob</span></tt> metadata.</p>
</div>
<div class="section" id="binding-a-schema-to-an-application">
<h2>10.2. Binding a Schema to an Application<a class="headerlink" href="#binding-a-schema-to-an-application" title="Permalink to this headline">¶</a></h2>
<p>We would like to be sure that our application&#8217;s expectations for a
schema are aligned with the schema actually present.
An application has several ways to bind its schema information.</p>
<ul class="simple">
<li><strong>Implicitly</strong>.  The code simply mentions specific columns
(either by name or position).</li>
<li><strong>Explicitly</strong>.   The code has a formal &#8220;requires&#8221; check to be sure
that the schema provided by the file actually matches the
schema required by the application.</li>
</ul>
<p>Explicit schema binding parallels the configuration management issue of module
dependency. A file can be said to <em>provide</em> a given schema and an
application <em>requires</em> a given schema.</p>
<p>Sadly, we don&#8217;t always have a pithy summary of a schema.  It would be nice to
call it <tt class="docutils literal"><span class="pre">econometrics_vendorX_1.2</span></tt> where we identify the
generic type of data, the source for that file, and the schema version
number.  We might be able to work something like this out.
First, however, let&#8217;s allow for variant schemas and get those bound
to file and application.</p>
<p>We&#8217;ll look at some approaches to this in <a class="reference internal" href="#schema-version-numbering">Schema Version Numbering</a>,
below.</p>
<p>If we don&#8217;t implement this,
we&#8217;re left with implicit schema binding in our applications.</p>
</div>
<div class="section" id="schema-version-numbering">
<h2>10.3. Schema Version Numbering<a class="headerlink" href="#schema-version-numbering" title="Permalink to this headline">¶</a></h2>
<p>XSD&#8217;s can have version numbers.  This is a very cool.</p>
<p>See <a class="reference external" href="http://www.xfront.com/Versioning.pdf">http://www.xfront.com/Versioning.pdf</a> for detailed discussion of how
to represent schema version information.</p>
<p>Databases, however, lack version numbering in the schema.  This leads to potential
compatibilty issues between application programs that expect version 3 of the
schema and an older database that implements version 2 of the schema.</p>
<p>Our file schema, similarly, don&#8217;t have a tidy, unambiguous numbering.</p>
<p>For external schema, we can embed the version in the file names.</p>
<p>For a database schema, we can easily use the schema name to carry
version information.  We could have a <tt class="samp docutils literal"><span class="pre">name_</span><em><span class="pre">version</span></em></tt> kind of
convention for all schema, allowing an application to confirm schema
compatibility with a trivial query.</p>
<p>For embedded schema, however, we have no <em>easy</em> to handle schema identification
and version numbering.  We could
build an algorithm to compare the embedded schema against other (external)
schemata to determine a matching version.</p>
<p>This may lead to further data profiling to reason out what the file is.
At about this point, the operation is better done manually.  Checking
the embedded schema against existing schema and a manual examination
of the data profiling will allow a human to determine the schema.</p>
<p>Then, once the schema has been identified, command-line options
can be used to bind the schema to file for correct processing.</p>
</div>
<div class="section" id="data-attribute-mapping-using-a-schema">
<h2>10.4. Data Attribute Mapping &#8211; Using a Schema<a class="headerlink" href="#data-attribute-mapping-using-a-schema" title="Permalink to this headline">¶</a></h2>
<p>Using a schema is the heart of the semantic problem.</p>
<p>We want to have just one application that is adaptable to a number
of closely-related data file schemata.  Ideally, there&#8217;s one,
but as a practical matter, there
are several similar schema.</p>
<p>We need to provide three pieces of information, minimally.</p>
<ul class="simple">
<li>Target attribute within our application.</li>
<li>Target Data type conversion.</li>
<li>Source attribute based on name or position.</li>
</ul>
<p>We could use a number of different encodings for this relationship.
We could write it as properties, or XML, or some other notation.</p>
<p>However, that triple is essentially a Python assignment statement
with <em>target</em>, <em>to_type</em> and <em>source</em>.</p>
<pre class="literal-block">
<em>target</em> = row.cell( schema[&#8216;<em>source</em>&#8216;] ).*to_type*()
</pre>
<p>There is a tiny bit of boilerplate in this assignment statement.
When using repeating groups, items with duplicated column names, or REDEFINES clauses, the &#8220;boilerplate&#8221; expands to necessary code.  In particular, the
lazy extraction of cell values is often essential.</p>
<p>In the case where there are no repeating groups, or REDEFINES clauses, we can make our API
more fluent by building a row dictionary from row and schema.  This kind of
eager cell processing is risky.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">row_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">schema</span> <span class="p">)</span>
</pre></div>
</div>
<p>This allows the following  <em>target</em>, <em>to_type</em> and <em>source</em> triple.</p>
<pre class="literal-block">
<em>target</em> = row[&#8216;<em>source</em>&#8216;].*to_type*()
</pre>
<p>For multiple attributes, this is our use case.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">build_record</span><span class="p">(</span> <span class="n">aRow</span> <span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;some column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;another column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_digit_str</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_digit_str</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>The idea is to build an application-specific mapping from a row
in a file, given the logical layout information buried in the schema
definition.</p>
<p>Of course, the schema can lie, and the application can misuse the data.
Those are inevitable (and therefore insoluble) problems.  This is why
we must write customized software to handle these data sources.</p>
<p>In the case of variant schemata, we would like something like this.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">build_record_1</span><span class="p">(</span> <span class="n">aRow</span> <span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;some column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">arow</span><span class="p">[</span><span class="s">&#39;another column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_digit_str</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_digit_str</span><span class="p">(),</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">build_record_2</span><span class="p">(</span> <span class="n">aRow</span> <span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;variant column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">arow</span><span class="p">[</span><span class="s">&#39;different column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_digit_str</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_digit_str</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="make_builder">
<tt class="descname">make_builder</tt><big>(</big><em>args</em><big>)</big><a class="headerlink" href="#make_builder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_builder</span><span class="p">(</span> <span class="n">args</span> <span class="p">):</span>
    <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span> <span class="s">&#39;build_record_{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">layout</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#make_builder" title="make_builder"><tt class="xref py py-func docutils literal"><span class="pre">make_builder()</span></tt></a> function selects one of the available
builders based on a run-time option.</p>
</div>
<div class="section" id="data-transformation">
<h2>10.5. Data Transformation<a class="headerlink" href="#data-transformation" title="Permalink to this headline">¶</a></h2>
<p>Under <a class="reference internal" href="cell.html#cells"><em>Cell Module &#8211; Data Element Containers and Conversions</em></a> above, we noted that there are two
parts to data handling: Capture and Conversion.  Capture is part
of parsing the physical format.  Conversion is part of the final
application, and has nothing to do with the schema that describes
the data source.</p>
<p>A target data type transformation (or conversion) could be considerably more complex
than the trivial case of decoding a floating-point number to a digit
string.  It could involve any combination of filtering, cleansing,
conforming to an existing database, or rewriting.</p>
<div class="highlight-python"><pre>def build_record_3( aRow ):
    if aRow['flag'].is_empty():
        return None
    zip_str = aRow['zip'].to_str()
    if '-' not in zip:
        if len(zip) &lt;= 5:
            zip= aRow['zip'].to_digit_str(5)
        else:
            zip= aRow['zip'].to_digit_str(9)
    else:
        zip= zip_str.replace('-'.'')
    return dict(
        name = aRow['variant column'].to_str(),
        address = arow['different column'].to_str(),
        zip = zip,
        phone = aRow['phone'].to_digit_str(),
    )</pre>
</div>
<p>This shows filtering and cleasing operations.  Yes, it&#8217;s complex.
Indeed, it&#8217;s complex enough that alternative languages (i.e., properties,
XLST, etc.) are much less clear than simple Python.</p>
</div>
<div class="section" id="stingray-application-design">
<h2>10.6. <tt class="docutils literal"><span class="pre">stingray</span></tt> Application Design<a class="headerlink" href="#stingray-application-design" title="Permalink to this headline">¶</a></h2>
<p>For testability, each application needs to be decomposed into several levels of
processing.</p>
<ul class="simple">
<li>Row-Level.  Inidividual Python objects built from a row of the input.</li>
<li>Sheet-Level.  Collections of Python objects built from rows.</li>
<li>Workbook-Level.  Collections of sheets.</li>
</ul>
<p>Each of these tiers is separated to facilitate unit testing.  Generally,
the testing goes two ways.  We test our application to be sure the schemata
are used properly.    In <a class="reference internal" href="demo/data_quality.html#demo-sqa"><em>Data Validation &#8211; Unit Level</em></a>, we&#8217;ll look at how we
apply unit tests validate that the the input files have the expected schema.</p>
<div class="section" id="row-level-processing">
<h3>10.6.1. Row-Level Processing<a class="headerlink" href="#row-level-processing" title="Permalink to this headline">¶</a></h3>
<p>Row-level processing is centered on a suite of builder functions.
These handle the detailed mapping
from variant logical layouts to a single, standardized conceptual schema.</p>
<p>Each builder creates a simple dictionary.  Each dictionary key is the standardized
attribute names used by internal Python class definitions.</p>
<p><strong>Q</strong>.  Why not build the final Python objects from the source row?</p>
<p><strong>A</strong>.  The source row needs to be validated to see if an object can be built.
It seems simpler to map the logical layout in the source document to a
standardized structure that matches the conceptual schema.  This standardized
structure can be validated.</p>
<p>This follows the design patterns from the Django project where a <tt class="docutils literal"><span class="pre">ModelForm</span></tt> is used to validate data before attempting to build a <tt class="docutils literal"><span class="pre">Model</span></tt> instance.</p>
<pre class="literal-block">
def builder_1( row ):
    return dict(
        <em>key</em> = row.cell( row.sheet.schema[&#8216;field&#8217;] ).to_type(),
    )

def is_valid( row_dict ):
    <em>All present or accounted for?</em>
    return <em>state</em>

def make_app_object( row_dict ):
    return App_Object( **row_dict )
</pre>
<p>This allows us to pick the builder based on a &#8220;logical layout&#8221; command-line
option.  Something like the following is used to make an application
flexible with respect to layout.</p>
<div class="highlight-python"><pre>def make_builder( args ):
    if args.layout in ("1", "D", "d"):
        return builder_1
    elif args.layout == "2":
        return builder_2
    else
        raise Exception( "Unknown layout value: {0}".format(args.layout) )</pre>
</div>
<p>To avoid updating this <tt class="docutils literal"><span class="pre">if</span></tt> statement, yet more Python features can be used.</p>
<p>For example, we might want to package all builders in a separate module.
This provides a focused location for change that leaves the application
untouched when handling Yet Another Logical Layout, y&#8217;all.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_builder</span><span class="p">(</span> <span class="n">args</span> <span class="p">):</span>
    <span class="n">builder_name</span> <span class="o">=</span> <span class="s">&#39;builder_{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">args</span><span class="o">.</span><span class="n">layout</span> <span class="p">)</span>
    <span class="nb">globals</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="nb">execfile</span><span class="p">(</span> <span class="s">&#39;builders.py&#39;</span><span class="p">,</span> <span class="nb">globals</span> <span class="p">)</span>
    <span class="k">return</span> <span class="nb">globals</span><span class="p">[</span><span class="n">builder_name</span><span class="p">]</span>
</pre></div>
</div>
<p>Or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_builder</span><span class="p">(</span> <span class="n">args</span> <span class="p">):</span>
    <span class="kn">import</span> <span class="nn">builders</span>
    <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;builders.builder_{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">args</span><span class="o">.</span><span class="n">layout</span> <span class="p">))</span>
</pre></div>
</div>
<p>The builders are tested individually.  They are subject to considerable change.
New builders are created frequently.</p>
<p>The validation should be common to all logical layouts.
It&#8217;s not subject to much variation.
The testing of validation and processing is still important,
but it doesn&#8217;t have the change velocity that builders have.</p>
</div>
<div class="section" id="sheet-level-processing">
<h3>10.6.2. Sheet-Level Processing<a class="headerlink" href="#sheet-level-processing" title="Permalink to this headline">¶</a></h3>
<p>The next higher layer is sheet-level processing.  For the most part,
sheets are generally rows of a single logcal type.  In exceptional cases,
a sheet may have multiple types coincedentally bound into a single sheet.
We&#8217;ll return to the multiple-types-per-sheet issue below.</p>
<p>For the single-type-per-sheet, we have a processing function like
the following.</p>
<dl class="function">
<dt id="process_sheet">
<tt class="descname">process_sheet</tt><big>(</big><em>sheet</em>, <em>builder</em><big>)</big><a class="headerlink" href="#process_sheet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
def process_sheet( sheet, builder=builder_1 ):
    counts= defaultdict( int )
    object_iter = (
        builder(row))
        for row in sheet.schema.rows_as_dict_iter(sheet) )
    for source in object_iter:
        counts[&#8216;input&#8217;] += 1
        if is_valid(source):
            counts[&#8216;valid&#8217;] += 1
            # <em>The real processing</em>
            obj= make_app_object( source )
            obj.save()
        else:
            counts[&#8216;invalid&#8217;] += 1
    return counts
</pre>
<p>This kind of sheet is tested two ways.  First, with a test fixture that provides
specific rows based on requirements, edge-cases and other &#8220;white-box&#8221; considerations.</p>
<p>It is also tested with &#8220;live-file&#8221;.  The counts can be checked.  This actually
tests the file as much as it tests the sheet processing function.</p>
<p>When processing multiple-types-per-sheet, there are two choices for doing this.</p>
<ul class="simple">
<li>Multiple-Pass and Filters.</li>
<li>One Pass and Switch.</li>
</ul>
<p>The multiple-pass option looks like this.  Each pass applies a filter and
then does the appropriate processing.</p>
<pre class="literal-block">
def process_sheet_filter_1( sheet ):
    counts= defaultdict( int )
    object_iter = (
        builder(row))
        for row in sheet.schema.rows_as_dict_iter(sheet) )
    for source in object_iter:
        counts[&#8216;input&#8217;] += 1
        if <em>filter_1(source)</em>:
            counts[&#8216;accept&#8217;] += 1
            <em>processing_1(source)</em>
        else:
            counts[&#8216;reject&#8217;] += 1
</pre>
<p>The one-pass option looks like this.  A &#8220;switch&#8221; function is used to
discriminate each kind of row that is found in the sheet.</p>
<pre class="literal-block">
def process_sheet_switch( sheet ):
    counts= defaultdict( int )
    object_iter = (
        builder(row))
        for row in sheet.schema.rows_as_dict_iter(sheet) )
    for source in object_iter:
        counts[&#8216;input&#8217;] += 1
        if <em>switch_1(source)</em>:
            counts[&#8216;accept-1&#8217;] += 1
            <em>processing_1(source)</em>
        elif <em>switch_2(source)</em>:
            counts[&#8216;accept-2&#8217;] += 1
            <em>processing_2(source)</em>
        <em>elif etc.</em>
        else:
            counts[&#8216;reject&#8217;] += 1
</pre>
<p>Both approaches work well; there&#8217;s no &#8220;better&#8221;.
The overhead of multiple passes may be higher because
of the I/O cost for a large sheet of data.</p>
<p>The multiple pass design can work out particularly well with multi-processing.
Each <tt class="docutils literal"><span class="pre">process_sheet_filter_x</span></tt> function can be started as independent processes to work in parallel.</p>
<p>For smaller sheets of data &#8211; sheets that fit in memory &#8211; multiple passes
may  be the same cost as a single pass with a complex switch.</p>
</div>
<div class="section" id="workbook-processing">
<h3>10.6.3. Workbook Processing<a class="headerlink" href="#workbook-processing" title="Permalink to this headline">¶</a></h3>
<p>The overall processing of a given workbook input looks like this.</p>
<dl class="function">
<dt id="process_workbook">
<tt class="descname">process_workbook</tt><big>(</big><em>sheet</em>, <em>builder</em><big>)</big><a class="headerlink" href="#process_workbook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
def process_workbook( source, builder ):
    for name in source.sheets():
        # <em>Sheet filter?  Or multi-way elif switch?</em>
        sheet= source.sheet( name,
            sheet.EmbeddedSchemaSheet,
            loader_class=schema.loader.HeadingRowSchemaLoader )
        counts= process_sheet( sheet, builder )
        pprint.pprint( counts )
</pre>
<p>This makes two claims about the workbook.</p>
<ul class="simple">
<li>All sheets in the workbook have the same schema rules.
In this example, it&#8217;s an embedded schema in each sheet and the schema is the heading row.
We could easily use an ExternalSchemaSheet and an external schema.</li>
<li>A single <a class="reference internal" href="#process_sheet" title="process_sheet"><tt class="xref py py-func docutils literal"><span class="pre">process_sheet()</span></tt></a> function is appropriate for all sheets.</li>
</ul>
<p>If a workbook doesn&#8217;t meet these criteria, then a (potentially) more complex
workbook processing function is needed.  A sheet filter is usually necessary.</p>
<p>Sheet name filtering is also subject to the kind of change that
builders are subject to.  Each variant logical layout may also have
a variation in sheet names.  It helps to separate the sheet filter functions
in the same way builders are separated.   New functions are added with
remarkable regularity</p>
<pre class="literal-block">
def sheet_filter_1( name ):
    return re.match( r&#8217;<em>pattern</em>&#8216;, name )
</pre>
<p>Or, perhaps something like this that uses a shell file-name pattern instead of a
more sophisticated regular expression.</p>
<pre class="literal-block">
def sheet_filter_2( name ):
    return fnmatch.fnmatch( name, &#8216;<em>pattern</em>&#8216; )
</pre>
</div>
<div class="section" id="command-line-interface">
<h3>10.6.4. Command-Line Interface<a class="headerlink" href="#command-line-interface" title="Permalink to this headline">¶</a></h3>
<p>We have an optional argument for verbosity and a positional argument that
provides all the files to profile.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="n">parser</span><span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span> <span class="s">&#39;file&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s">&#39;+&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span> <span class="s">&#39;-l&#39;</span><span class="p">,</span> <span class="s">&#39;--layout&#39;</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span> <span class="s">&#39;-v&#39;</span><span class="p">,</span> <span class="s">&#39;--verbose&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;verbosity&#39;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_const&#39;</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
</pre></div>
</div>
<p>The overall main program looks something like this.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span> <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span> <span class="p">)</span>
    <span class="n">args</span><span class="o">=</span> <span class="n">parse_args</span><span class="p">()</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span> <span class="n">args</span><span class="o">.</span><span class="n">verbosity</span> <span class="p">)</span>
    <span class="n">builder</span><span class="o">=</span> <span class="n">make_builder</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">workbook</span><span class="o">.</span><span class="n">open_workbook</span><span class="p">(</span> <span class="nb">input</span> <span class="p">)</span> <span class="k">as</span> <span class="n">source</span><span class="p">:</span>
                <span class="n">process_workbook</span><span class="p">(</span> <span class="n">source</span><span class="p">,</span> <span class="n">builder</span> <span class="p">)</span>
        <span class="n">status</span><span class="o">=</span> <span class="mi">0</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span> <span class="n">e</span> <span class="p">)</span>
        <span class="n">status</span><span class="o">=</span> <span class="mi">3</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span> <span class="n">status</span> <span class="p">)</span>
</pre></div>
</div>
<p>This main program switch allows us to test the various functions (<a class="reference internal" href="#process_workbook" title="process_workbook"><tt class="xref py py-func docutils literal"><span class="pre">process_workbook()</span></tt></a>, <a class="reference internal" href="#process_sheet" title="process_sheet"><tt class="xref py py-func docutils literal"><span class="pre">process_sheet()</span></tt></a>, the builders, etc.) in isolation.</p>
<p>It also allows us to reuse these functions to build larger (and more complete)
applications from smaller components.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Stingray_belon1553_small.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">10. <tt class="docutils literal"><span class="pre">stingray</span></tt> Developer&#8217;s Guide</a><ul>
<li><a class="reference internal" href="#binding-a-schema-to-a-file">10.1. Binding a Schema to a File</a></li>
<li><a class="reference internal" href="#binding-a-schema-to-an-application">10.2. Binding a Schema to an Application</a></li>
<li><a class="reference internal" href="#schema-version-numbering">10.3. Schema Version Numbering</a></li>
<li><a class="reference internal" href="#data-attribute-mapping-using-a-schema">10.4. Data Attribute Mapping &#8211; Using a Schema</a></li>
<li><a class="reference internal" href="#data-transformation">10.5. Data Transformation</a></li>
<li><a class="reference internal" href="#stingray-application-design">10.6. <tt class="docutils literal"><span class="pre">stingray</span></tt> Application Design</a><ul>
<li><a class="reference internal" href="#row-level-processing">10.6.1. Row-Level Processing</a></li>
<li><a class="reference internal" href="#sheet-level-processing">10.6.2. Sheet-Level Processing</a></li>
<li><a class="reference internal" href="#workbook-processing">10.6.3. Workbook Processing</a></li>
<li><a class="reference internal" href="#command-line-interface">10.6.4. Command-Line Interface</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cobol_loader.html"
                        title="previous chapter">9. COBOL Loader Module &#8211; Parse COBOL Source to Load a Schema</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="demo/index.html"
                        title="next chapter">11. Data Quality Assurance Applications</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/logical_layout.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="demo/index.html" title="11. Data Quality Assurance Applications"
             >next</a> |</li>
        <li class="right" >
          <a href="cobol_loader.html" title="9. COBOL Loader Module – Parse COBOL Source to Load a Schema"
             >previous</a> |</li>
        <li><a href="index.html">The Stingray Schema-Based File Reader</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, S. Lott.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>