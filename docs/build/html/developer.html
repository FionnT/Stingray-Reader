
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Using Stingray Reader &#8212; Stingray-Reader 5.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Demo Applications" href="demo/index.html" />
    <link rel="prev" title="Design Considerations" href="design.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="using-stingray-reader">
<span id="developer"></span><h1>Using <strong>Stingray Reader</strong><a class="headerlink" href="#using-stingray-reader" title="Permalink to this headline">¶</a></h1>
<p>We use <strong>Stingray</strong> to work with data files where the schema is
either external or complex (or both). We can tackle this question:</p>
<blockquote>
<div><p><strong>How do we process a file simply and consistently?</strong></p>
</div></blockquote>
<p>Or, more concretely,</p>
<blockquote>
<div><p><strong>How do we make a program independent of Physical Format and Logical Layout?</strong></p>
</div></blockquote>
<p>We can also use <strong>Stingray</strong> to answer questions about files, the schema those
files purport to use, and the data on those files.
Specifically, we can tackle this question:</p>
<blockquote>
<div><p><strong>How do we ensure that a file and an application use the same schema?</strong></p>
</div></blockquote>
<p>We do need to note the following.</p>
<blockquote>
<div><p><strong>If it was simple, we wouldn’t need this package, would we?</strong></p>
</div></blockquote>
<section id="concepts">
<h2>Concepts<a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h2>
<p>As noted in <a class="reference internal" href="introduction.html#intro"><span class="std std-ref">Introduction</span></a>, there are three levels of schema that need to be bound to a file.</p>
<ul class="simple">
<li><p><strong>Physical Format</strong>.  We can make this transparent to our applications.
When using Stingray Reader, everything is a workbook with a consistent API.</p></li>
<li><p><strong>Logical Layout</strong>.  This is how an application program will make use
of the data found in a file.
Sometimes the Logical Layout is described by a schema embedded in a file:
it might be the top row of a sheet in a workbook, for example.
Sometimes the logical layout can be separate: a COBOL data definition, or perhaps
a metadata sheet in a workbook.</p></li>
<li><p><strong>Conceptual Content</strong>.
A single conceptual schema may be implemented by a number of physical
formats and logical layouts.
An application should be able to tolerate variability in the logical
layout as long is it matches the expected <strong>conceptual content</strong>.</p></li>
</ul>
<p>We can’t make the logical layout completely transparent.
Our suite of applications all need to agree on a logical layout.
A change to one application’s production or consumption must lead to a change to the others.
The column names in the metadata, at a bare minimum, must be agreed to.
The order or position of the columns, however, need not be fixed.</p>
<p>Since we’re working in Python, the conceptual schema is often a class
definition. The idea is to provide many ways to build a class instance
based on variations in the logical layout.</p>
<p>There are two sides to schema use:</p>
<ul class="simple">
<li><p><strong>Within the Application</strong>. To process a data file, we need to bind schema information to the file.
For a workbook, the schema may be in the column headings of the sheet.
Or it may be in a separate sheet, or a separate workbook.
For a COBOL file, the schema is always in a separate COBOL-language
data definition.</p></li>
<li><p><strong>Data Quality</strong>. Given a data file, how do we confirm that some schema matches the file?</p></li>
</ul>
<p>We’ll tackle the schema binding in several pieces.</p>
<ul class="simple">
<li><p><strong>File Schema</strong>.  <a class="reference internal" href="#binding-a-schema-to-a-file">Binding a Schema to a File</a> describes some preliminary
operational steps that make Stingray work more simply and reliably.</p></li>
<li><p><strong>Processing</strong>. There are two concepts: <strong>Capture</strong> and <strong>Conversion</strong>.
The <a class="reference internal" href="#data-attribute-mapping-using-a-schema">Data Attribute Mapping – Using a Schema</a> section discusses design patterns for capture.
The <a class="reference internal" href="#data-transformation">Data Transformation</a> section focuses on conversion.</p></li>
<li><p><strong>Application Design Patterns</strong>. These are more complex issues.
We can then dig into <strong>Stingray</strong> application programming in <a class="reference internal" href="#stingray-application-design">stingray Application Design</a>,
<a class="reference internal" href="#variant-records-and-cobol-redefines">Variant Records and COBOL REDEFINES</a>, and <a class="reference internal" href="#big-data-performance">Big Data Performance</a>.</p></li>
<li><p><strong>Data Management</strong>. <a class="reference internal" href="#file-naming-and-external-schema">File Naming and External Schema</a>,
<a class="reference internal" href="#binding-a-schema-to-an-application">Binding a Schema to an Application</a>, and <a class="reference internal" href="#schema-version-numbering">Schema Version Numbering</a>.</p></li>
<li><p><strong>FAQ</strong>. Some other design questions. <a class="reference internal" href="#frequently-asked-questions">Frequently Asked Questions</a>.</p></li>
</ul>
<p>We’ll look at some demonstration software in <a class="reference internal" href="demo/index.html#demo"><span class="std std-ref">Demo Applications</span></a>.</p>
</section>
<section id="binding-a-schema-to-a-file">
<h2>Binding a Schema to a File<a class="headerlink" href="#binding-a-schema-to-a-file" title="Permalink to this headline">¶</a></h2>
<p>The file suffix, e.g., <code class="docutils literal notranslate"><span class="pre">.xlsx</span></code>, binds a file’s collection of bytes to a physical format.
This pattern is relatively universal. A single <code class="xref py py-func docutils literal notranslate"><span class="pre">stingray.open_workbook()</span></code> function
looks at the file suffix and locates an appropriate class.</p>
<p>A decorator is available to extend Stingray’s file suffix mapping to introduce new
physical format bindings.</p>
<p>We need to bind the logical layout to the file also.
This means relying on a schema, defined by the
<a class="reference internal" href="apidoc/modules/stingray.schema_instance.html#stingray.schema_instance.Schema" title="stingray.schema_instance.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.schema_instance.Schema</span></code></a> class to describe
the logical layout of a file.
The <a class="reference internal" href="apidoc/modules/stingray.workbook.html#stingray.workbook.Sheet" title="stingray.workbook.Sheet"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.workbook.Sheet</span></code></a> and <a class="reference internal" href="apidoc/modules/stingray.workbook.html#stingray.workbook.Row" title="stingray.workbook.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.workbook.Row</span></code></a> classes
use a <a class="reference internal" href="apidoc/modules/stingray.schema_instance.html#stingray.schema_instance.Schema" title="stingray.schema_instance.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.schema_instance.Schema</span></code></a> object to describe each row.</p>
<p>An application must load the schema first. There several sources for schema:</p>
<ul class="simple">
<li><p><strong>Embedded</strong>.  This is commonly seen as column titles within the sheet.  Or
any variation on that theme. The common case of column titles is handled
by a built-in schema loader, <a class="reference internal" href="apidoc/modules/stingray.workbook.html#stingray.workbook.HeadingRowSchemaLoader" title="stingray.workbook.HeadingRowSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.workbook.HeadingRowSchemaLoader</span></code></a>.
Other variations are managed by building different schema loaders.</p></li>
<li><p><strong>External</strong>.  This is a separate sheet or separate file. In this case, we
can start with <a class="reference internal" href="apidoc/modules/stingray.workbook.html#stingray.workbook.ExternalSchemaLoader" title="stingray.workbook.ExternalSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.workbook.ExternalSchemaLoader</span></code></a> to read
an external schema. In the case of COBOL files, there’s a separate
<a class="reference internal" href="apidoc/modules/stingray.workbook.html#stingray.workbook.COBOLSchemaLoader" title="stingray.workbook.COBOLSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.workbook.COBOLSchemaLoader</span></code></a> that parses COBOL source to create
a usable schema.</p></li>
</ul>
<p>All schemae start as JSONSchema documents. These are Python <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">Any]</span></code> structures.
A <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.workbook.SchemaMaker</span></code> object is used to transform the JSONSchema
document into a usable <a class="reference internal" href="apidoc/modules/stingray.schema_instance.html#stingray.schema_instance.Schema" title="stingray.schema_instance.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.schema_instance.Schema</span></code></a> object. This permits
pre-processing the schema to add features or correct problems.</p>
</section>
<section id="data-attribute-mapping-using-a-schema">
<h2>Data Attribute Mapping – Using a Schema<a class="headerlink" href="#data-attribute-mapping-using-a-schema" title="Permalink to this headline">¶</a></h2>
<p>Data processing starts with <strong>Capture</strong>.
Using a schema is the heart of solving the semantic problem of capturing data in spreadsheet and COBOL files.</p>
<p>We want to have just one application that is adaptable to a number
of variant logical layouts that reflect alternative implementations of a single conceptual content.
Ideally, there’s one layout and one schema, but as a practical matter, there are often several similar schemae.</p>
<p>We need to provide three pieces of information.</p>
<ul class="simple">
<li><p>Target attribute name or parameter used by our application.</p></li>
<li><p>Target data type conversion for our application.</p></li>
<li><p>Source attribute based on attribute name or position in the source file.</p></li>
</ul>
<p>This tripl is essentially a Python assignment statement
with <em>target</em>, <em>to_type</em> and <em>source</em>. A DSL or other encoding is unhelpful.</p>
<p>A simple description is the following:</p>
<pre class="literal-block"><em>target</em> = <em>target_type</em>(row.['<em>source</em>'].value())</pre>
<p>There is a tiny bit of boilerplate in this assignment statement. The overhead of the boilerplate
is offset by the flexibility of using Python directly.</p>
<p>There are some common cases that will extend or modify the boilerplate.
In particular, COBOL structures that are not in first normal form will include
array indexing. COBOL can have ambiguous names, requiring a navigation path to
an atomic value. Finally, because of the COBOL redefines feature, it helps to
do lazy evaluation to compute the value after navgiating to the desired string of bytes.</p>
<p>This is our preferred design pattern: a <strong>Builder Function</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_record_dict</span><span class="p">(</span><span class="n">aRow</span><span class="p">:</span> <span class="n">Row</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;some column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;another column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_5</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>This function defines the application-specific mapping from a row
in a file. It leverages logical layout information from the schema
definition.</p>
<p>Of course, the schema can lie, and the application can misuse the data.
Those are inevitable (and therefore insoluble) problems.  This is why
we must write customized software to handle these data sources.</p>
<p>In the case of variant schemae, we can use like something like this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_record_dict_1</span><span class="p">(</span><span class="n">aRow</span><span class="p">:</span> <span class="n">Row</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;some column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;another column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_5</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">build_record_dict_2</span><span class="p">(</span><span class="n">aRow</span><span class="p">:</span> <span class="n">Row</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;variant column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;something different&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_5</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>We can then define a handy factory which picks a builder based on the schema
version.</p>
<dl class="py function">
<dt class="sig sig-object py" id="make_builder">
<span class="sig-name descname"><span class="pre">make_builder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#make_builder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a builder object from the args.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> – schema version</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>appropriate builder function for the schema</p>
</dd>
</dl>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_builder</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Row</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;build_record_dict_</span><span class="si">{args.layout}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Some people worry that an Evil Super-Genius (ESG) might somehow try to exploit the <cite>eval()</cite> function.
The ESG would have to be both clever and utterly unaware that the source
is easily edited Python. People who worry about an ESG that can manipulate the parameters but
while unable to simply edit the Python can use the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="n">build_record_dict_1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="n">build_record_dict_2</span><span class="p">}[</span><span class="n">args</span><span class="o">.</span><span class="n">layout</span><span class="p">]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#make_builder" title="make_builder"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_builder()</span></code></a> function selects one of the available
builders based on a command-line option in the <code class="docutils literal notranslate"><span class="pre">args</span></code> structure.</p>
</section>
<section id="data-transformation">
<h2>Data Transformation<a class="headerlink" href="#data-transformation" title="Permalink to this headline">¶</a></h2>
<p>There are two parts to data handling: <strong>Capture</strong> and <strong>Conversion</strong>.
Conversion is part of the final application, once the source data has been captured.</p>
<p>A target data conversion can be rather complex.
It can involve involve any combination of filtering, cleansing, conforming to an existing database, or rewriting.</p>
<p>Here’s a much more complex <strong>Builder Function</strong> that includes conversion.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_record_3</span><span class="p">(</span><span class="n">aRow</span><span class="p">:</span> <span class="n">Row</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">aRow</span><span class="p">[</span><span class="s1">&#39;flag&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">zip_str</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s1">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">:</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_9</span><span class="p">(</span><span class="n">zip_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">zip</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_5</span><span class="p">(</span><span class="n">zip_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_9</span><span class="p">(</span><span class="n">zip_str</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s1">&#39;variant column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">arow</span><span class="p">[</span><span class="s1">&#39;different column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">,</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s1">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>This shows filtering and cleansing operations.  Yes, it’s complex.
Indeed, it’s complex enough that attempting to define a domain-specific language will lead to
more problems than simply using Python for this.</p>
</section>
<section id="stingray-application-design">
<h2><strong>Stingray</strong> Application Design<a class="headerlink" href="#stingray-application-design" title="Permalink to this headline">¶</a></h2>
<p>We need to consider two tiers of testing.  Conventional unit testing
makes sure our application’s processing is valid.
Beyond that, we also need to do data quality testing to
ensure that the data itself is valid.</p>
<p>For application unit testing, our programs should be decomposed into three tiers of
processing.</p>
<ul class="simple">
<li><p>Row-Level.  Inidividual Python objects built from one row of the input.
This involves our builder functions.</p></li>
<li><p>Sheet-Level.  Collections of Python objects built from all rows of a sheet.
This involves sheet processing functions. Mocked row-level functions should be used.</p></li>
<li><p>Workbook-Level.  In some cases, we may need to work with a collection of sheets.
If required, these tests will need mocked sheet and row functions.</p></li>
</ul>
<p>Each of these tiers should be tested independently.</p>
<p>For data quality testing, we need to validate that the the input files meet the expected schema.
This can use the unit testing framework. However, it’s often more helpful to
design application software to work in a “dry-run” or “validation” mode.
This operating mode can check the data without make persistent state changes
to other files or databases.</p>
<section id="row-level-processing">
<h3>Row-Level Processing<a class="headerlink" href="#row-level-processing" title="Permalink to this headline">¶</a></h3>
<p>Row-level processing is centered on the builder functions.
These handle the detailed mapping
from variant logical layouts to a single conceptual schema.</p>
<p>A builder function can create a simple dictionary or <code class="xref py py-class docutils literal notranslate"><span class="pre">types.SimpleNamespace</span></code>.</p>
<p>Note that there are two separate steps here.</p>
<ul class="simple">
<li><p>Preparing data for a candidate object. A <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">Any]</span></code> has data values.
There may be a number of different builder functions for this.</p></li>
<li><p>Building an application object from candidate data.
These objects are often a <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.NamedTuple</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">dataclasses.dataclass</span></code>.
These should not vary with the logical layout.</p></li>
</ul>
<p>This echoes the design patterns from the Django project where a <code class="docutils literal notranslate"><span class="pre">ModelForm</span></code>
is used to validate data before attempting to build a <code class="docutils literal notranslate"><span class="pre">Model</span></code> instance.</p>
<p>Validation within the class <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method, while possible, is often awkwardly complex.
There are two separate things bound together: validating and initialization. While these
can be separated into methods used by <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>, each change to a logical layout becomes
yet another subclass. In this case, composition seems more flexible than inheritance.</p>
<p>One additional reason for decomposing the building from the application object
construction is to support multiprocessing pipelines. It’s often quicker to serialize
a Python object built as <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">Any]</span></code> than to serialize an instance of a new class.</p>
<p>Here’s the three-part operation: <strong>Build, Validate, and Construct</strong>.</p>
<pre class="literal-block">def builder_1(row: Row) -&gt; dict[str, Any]:
    return dict(
        <em>key</em> = row['field'].vaue(),
    )

def is_valid(row_dict: dict[str, Any]) -&gt; bool:
    <em>All present or accounted for?</em>
    return <em>state</em>

def construct_object(row_dict: dict[str, Any]) -&gt; App_Object:
    return App_Object(**row_dict)</pre>
<p>The validation rules rarely change. The object construction doesn’t always
need to be a separate function, it can often be a simple class name, or a
classmethod of the class.</p>
<p>Our sheet processing can include a function like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span> <span class="o">=</span> <span class="n">make_builder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">sheet</span><span class="p">:</span>
    <span class="n">intermediate</span> <span class="o">=</span> <span class="n">builder</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_valid</span><span class="p">(</span><span class="n">intermediate</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">construct_object</span><span class="p">(</span><span class="n">intermediate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">builder()</span></code> function allows processing to vary with the file’s actual schema.
We need to pick the builder based on a “logical layout” command-line option.
Something like the following is used to make an application
flexible with respect to layout.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_builder</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Row</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">layout</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builder_1</span>
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builder_2</span>
    <span class="k">else</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown layout value: </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">layout</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The builders are tested individually.  They are subject to considerable change.
New builders are created frequently.</p>
<p>The validation should be common to all logical layouts.
It’s not subject to much variation.
The validation and object construction doesn’t have the change velocity that builders have.</p>
<p>Now that we can process individual rows, we need to provide a way to process
the collection of rows in a single sheet.</p>
</section>
<section id="sheet-level-processing">
<h3>Sheet-Level Processing<a class="headerlink" href="#sheet-level-processing" title="Permalink to this headline">¶</a></h3>
<p>For the most part, sheets are  rows of a single logcal type.  In exceptional cases,
a sheet may have multiple types coincedentally bound into a single sheet.
We’ll return to the multiple-types-per-sheet issue below.</p>
<p>For the single-type-per-sheet, we have a processing function like
the following.</p>
<dl class="py function">
<dt class="sig sig-object py" id="process_sheet">
<span class="sig-name descname"><span class="pre">process_sheet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sheet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">builder</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#process_sheet" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the given sheet using the given builder.</p>
</dd></dl>

<pre class="literal-block">def process_sheet(sheet: Sheet, builder: Builder = builder_1) -&gt; Counter:
    counts = Counter()
    object_iter = (
        builder(row)
        for row in sheet.row_iter()
    )
    for source in object_iter:
        counts['read'] += 1
        if is_valid(source):
            counts['valid'] += 1
            # <em>The real processing</em>
            obj = make_app_object(source)
            obj.save()
        else:
            counts['invalid'] += 1
    return counts</pre>
<p>This kind of sheet is tested two ways.  First, this can
have a unit test with a fixture that provides
specific rows based on requirements, edge-cases and other “white-box” considerations.</p>
<p>Second, an integration test can be performed with live data.
The counts can be checked.  This actually tests the file as much as it tests the sheet processing function.</p>
</section>
<section id="workbook-processing">
<h3>Workbook Processing<a class="headerlink" href="#workbook-processing" title="Permalink to this headline">¶</a></h3>
<p>The overall processing of a given workbook input looks like this.</p>
<dl class="py function">
<dt class="sig sig-object py" id="process_workbook">
<span class="sig-name descname"><span class="pre">process_workbook</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">builder</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#process_workbook" title="Permalink to this definition">¶</a></dt>
<dd><p>Process all sheets of the workbook using the given builder.</p>
</dd></dl>

<pre class="literal-block">def process_workbook(source: Workbook, builder: Builder) -&gt; None:
    for name in source.sheet_iter():
        # <em>Sheet filter?  Or multi-way elif switch?</em>
        sheet = source.sheet(name).set_schema_loader(HeadingRowSchemaLoader)
        counts = process_sheet(sheet, builder)
        pprint.pprint(counts)</pre>
<p>This makes two claims about the workbook.</p>
<ul class="simple">
<li><p>All sheets in the workbook have the same schema rules.
In this example, it’s an embedded schema in each sheet and the schema is the heading row.</p></li>
<li><p>A single <a class="reference internal" href="#process_sheet" title="process_sheet"><code class="xref py py-func docutils literal notranslate"><span class="pre">process_sheet()</span></code></a> function is appropriate for all sheets.</p></li>
</ul>
<p>If a workbook doesn’t meet these criteria, then a (potentially) more complex
workbook processing function is needed.  A sheet filter is usually necessary.</p>
<p>Sheet name filtering is also subject to the kind of change that
builders are subject to.  Each variant logical layout may also have
a variation in sheet names.  It helps to separate the sheet filter functions
in the same way builders are separated.   New functions are added with
remarkable regularity</p>
<pre class="literal-block">def sheet_filter_1(name: str):
    return re.match(r'<em>pattern</em>', name)</pre>
<p>Or, perhaps something like this that uses a shell file-name pattern instead of a
more sophisticated regular expression.</p>
<pre class="literal-block">def sheet_filter_2(name: str):
    return fnmatch.fnmatch(name, '<em>pattern</em>')</pre>
</section>
<section id="command-line-interface">
<h3>Command-Line Interface<a class="headerlink" href="#command-line-interface" title="Permalink to this headline">¶</a></h3>
<p>We have an optional argument for verbosity and a positional argument that
provides all the files to profile.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-l&#39;</span><span class="p">,</span> <span class="s1">&#39;--layout&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-v&#39;</span><span class="p">,</span> <span class="s1">&#39;--verbose&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;verbosity&#39;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_const&#39;</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
</pre></div>
</div>
<p>The overall main program looks something like this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">()</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">verbosity</span><span class="p">)</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">make_builder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">workbook</span><span class="o">.</span><span class="n">open_workbook</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="k">as</span> <span class="n">source</span><span class="p">:</span>
                <span class="n">process_workbook</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
</pre></div>
</div>
<p>This main program switch allows us to test the various functions (<a class="reference internal" href="#process_workbook" title="process_workbook"><code class="xref py py-func docutils literal notranslate"><span class="pre">process_workbook()</span></code></a>, <a class="reference internal" href="#process_sheet" title="process_sheet"><code class="xref py py-func docutils literal notranslate"><span class="pre">process_sheet()</span></code></a>, the builders, etc.) in isolation.</p>
<p>It also allows us to reuse these functions to build larger (and more complete)
applications from smaller components.</p>
<p>In <a class="reference internal" href="demo/index.html#demo"><span class="std std-ref">Demo Applications</span></a> we’ll look at two demonstration applications, as well as a unit
test.</p>
</section>
</section>
<section id="variant-records-and-cobol-redefines">
<h2>Variant Records and COBOL REDEFINES<a class="headerlink" href="#variant-records-and-cobol-redefines" title="Permalink to this headline">¶</a></h2>
<p>Ideally, a data source is in “first normal form”: all the rows are a single type
of data. We can apply a <strong>Build, Validate, Construct</strong> sequence simply.</p>
<p>In too many cases, a data source has multiple types of data. In COBOL files, it’s common
to have header records or trailer records which are summaries of the details
sandwiched in the middle.</p>
<p>Similarly, a spreadsheet may be populated with summary rows that must be discarded or
handled separately. We might, for example, write the summary to a different destination
and use it to confirm that all rows were properly processed.</p>
<p>Because of the COBOL <code class="docutils literal notranslate"><span class="pre">REDEFINES</span></code> clause, we have multiple variants within a schema.
The JSONSchema <code class="docutils literal notranslate"><span class="pre">oneOf</span></code> keyword captures this. This means that some of the alternatives
may not have a valid decoding for the bytes. This suggests that lazy evaluation of each
attribute of each row is essential.</p>
<p>We’ll look at a number of techniques for handling variant records.</p>
<section id="trivial-filtering">
<h3>Trivial Filtering<a class="headerlink" href="#trivial-filtering" title="Permalink to this headline">¶</a></h3>
<p>When loading a schema based on headers in the sheet,
the <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.HeadingRowSchemaLoader</span></code> class will be used.
We can extend this loader to reject rows, also.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">stingray.HeadingRowSchemaLoader.body()</span></code> method can do simple filtering.
This is most appropriate for excluding blank rows or summary rows from a spreadsheet.</p>
</section>
<section id="multiple-passes-and-filters">
<h3>Multiple Passes and Filters<a class="headerlink" href="#multiple-passes-and-filters" title="Permalink to this headline">¶</a></h3>
<p>When we have multiple data types within a single sheet, we can process this data
using the <strong>Multiple Passes and Filters</strong> pattern. Each pass through the data
uses different filters to separate the various types of data.</p>
<p>The multiple-pass option looks like this.  Each pass applies a filter and
then does the appropriate processing.</p>
<pre class="literal-block">def process_sheet_filter_1(sheet: Sheet):
    counts = Counter()
    for source in sheet.row_iter():
        counts['read'] += 1
        if <em>filter_1(row)</em>:
            intermediate = <em>builder(row)</em>
            counts['filter_1/pass'] += 1
            <em>processing_1(intermediate)</em>
        else:
            counts['filter_1/reject'] += 1
    return counts</pre>
<p>Each filter is a simple boolean function like this.</p>
<pre class="literal-block">def filter_1(source: Rpw) -&gt; bool:
    return <em>some condition</em></pre>
<p>The conditions may be small boolean expressions like <code class="docutils literal notranslate"><span class="pre">source['column'].value()</span> <span class="pre">==</span> <span class="pre">value</span></code>,
and a lambda object can be used. It’s generally a good practice to encapsulate them as distinct, named functions.</p>
</section>
<section id="one-pass-and-case">
<h3>One Pass and Case<a class="headerlink" href="#one-pass-and-case" title="Permalink to this headline">¶</a></h3>
<p>When we have multiple data types within a single sheet,
We can make  single pass over the data, using an <code class="docutils literal notranslate"><span class="pre">if-elif</span></code> chain or a <code class="docutils literal notranslate"><span class="pre">case-switch</span></code> statement.
Each type of row is handled separately.</p>
<p>The one-pass option looks like this.  A “switch” function is used to
discriminate each kind of row that is found in the sheet.</p>
<pre class="literal-block">def process_sheet_switch(sheet: Sheet) -&gt; Counter:
    counts = Counter(int)
    for row in sheet.row_iter():
        counts['read'] += 1
        if <em>switch_1(row)</em>:
            intermediate_1 = <em>builder_1(row)</em>
            <em>processing_1(intermediate_1)</em>
            counts['switch_1'] += 1
        elif <em>switch_2(row)</em>:
            intermediate_2 = <em>builder_2(row)</em>
            <em>processing_2(intermediate_2)</em>
            counts['switch_2'] += 1
        <em>elif etc.</em>
        else:
            counts['rejected'] += 1
    return counts</pre>
<p>Each switch function is a simple boolean function like this.</p>
<pre class="literal-block">def switch_1(row: Row) -&gt; bool:
    return <em>some condition</em></pre>
<p>The conditions may be trivial: <code class="docutils literal notranslate"><span class="pre">source['column'].value()</span> <span class="pre">==</span> <span class="pre">value</span></code>.</p>
<p>It often makes sense to package switch, builder, and processing into a single class.</p>
<p>We may be able to build a mapping from switch function results to process function.</p>
<p>This allows us to write a sheet processing function like this&gt;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_sheet_switch</span><span class="p">(</span><span class="n">sheet</span><span class="p">:</span> <span class="n">Sheet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counter</span><span class="p">:</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sheet</span><span class="o">.</span><span class="n">row_iter</span><span class="p">():</span>
        <span class="n">counts</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">choices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Row</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">switch_1</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="n">builder_1</span><span class="p">,</span> <span class="n">processing_1</span><span class="p">),</span>
            <span class="p">(</span><span class="n">switch_2</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="n">builder_2</span><span class="p">,</span> <span class="n">processing_2</span><span class="p">),</span>
            <span class="o">...</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">switch</span><span class="p">,</span> <span class="n">builder_function</span><span class="p">,</span> <span class="n">processing_function</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">switch</span><span class="p">:</span>
                <span class="n">processed</span> <span class="o">=</span> <span class="n">switch</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">processed</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">intermediate</span> <span class="o">=</span> <span class="n">builder_function</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                <span class="n">processing_function</span><span class="p">(</span><span class="n">intermediate</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">processed</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="s1">&#39;rejected&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts</span>
</pre></div>
</div>
<p>This can more easily be extended by adding to the <code class="docutils literal notranslate"><span class="pre">choices</span></code> mapping.</p>
</section>
<section id="more-complex-pipelines">
<h3>More complex pipelines<a class="headerlink" href="#more-complex-pipelines" title="Permalink to this headline">¶</a></h3>
<p>In many cases, we need to inject data quality validation before attempting
to build the application object.
If so, that can be added to the mapping.</p>
<p>It can help to define a class to contain the various pieces of the processing.</p>
<pre class="literal-block">class Sequence(abc.ABC):
    &#64;abstractmethod
    def switch(self, row: Row) -&gt; bool: ...
    &#64;abstractmethod
    def builder(self, row: Row) -&gt; dict[str, Any]: ...
    &#64;abstractmethod
    def validate(self, dict[str, Any]:) -&gt; bool: ...
    &#64;abstractmethod
    def process(self, dict[str, Any]) -&gt; None: ...

    def handle(self, row: Row) -&gt; str:
        name = self.__class__.__name__
        if not self.switch(row):
            return f&quot;{name}-reject&quot;
        intermediate = self.builder(row)
        if not valid(intermediate):
            return f&quot;{name}-invalid&quot;
        self.process(intermediate)
        return f&quot;{name}-process&quot;

class Record_Type_1(Sequence):
    def switch(self, row: Row) -&gt; bool:
        return <em>some expression</em>
    def builder(self, row: Row) -&gt; dict[str, Any]: ...
        return {
            <em>name</em> = row[<em>column</em>].value(),
            ...
        }
    def validate(self, intermediate: dict[str, Any]) -&gt; bool:
        return <em>some expression</em>
    def process(self, intermediate: dict[str, Any]) -&gt; None:
        <em>do something</em>

OPTIONS = [Record_Type_1(), Record_Type_2(), ...]</pre>
<p>This serves as the configuration for a number of processing alternatives.
New classes can be added and the <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> list updated to reflect the current
state of the processing.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_sheet_switch</span><span class="p">(</span><span class="n">sheet</span><span class="p">:</span> <span class="n">Sheet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counter</span><span class="p">:</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sheet</span><span class="o">.</span><span class="n">row_iter</span><span class="p">():</span>
        <span class="n">counts</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">OPTIONS</span><span class="p">:</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="n">option</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">outcome</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts</span>
</pre></div>
</div>
<p>This generic sheet processing can comfortably handle complex variant row
issues. It permits a single configuration via the <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> sequence
to handle records appropriately.</p>
<p>This design permits the switch conditions to overlap, potentially processing
a single row multiple times. If the conditions do not overlap, then the first
outcome that ends in “-process” would exit the loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">OPTIONS</span><span class="p">:</span>
    <span class="n">outcome</span> <span class="o">=</span> <span class="n">option</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">counts</span><span class="p">[</span><span class="n">outcome</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">outcome</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;-process&quot;</span><span class="p">):</span>
        <span class="k">break</span>
</pre></div>
</div>
<p>With this additional feature, the order of the conditions in the <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> list becomes
relevant. A general, fall-back <code class="docutils literal notranslate"><span class="pre">switch()</span></code> method condition must be last.</p>
</section>
</section>
<section id="big-data-performance">
<h2>Big Data Performance<a class="headerlink" href="#big-data-performance" title="Permalink to this headline">¶</a></h2>
<p>We’ve broken appllication processing down into separate steps which
work with generic Python data structures. This permits use of
multiprocessing to spread the pipeline into separate processors or cores.</p>
<p>We’ll set aside the initial switch decision-making for a moment and
focus on a three step <strong>Build, Vaidate, Process</strong> sequence of operations.
Each stage of of this sequence can be processed concurrently.</p>
<p>The <strong>Build</strong> stage uses a Sheet object’ss <code class="docutils literal notranslate"><span class="pre">row_iter()</span></code> method to gather
<code class="docutils literal notranslate"><span class="pre">Row</span></code> objects. These can be validated and an intermediate object created
and placed into a queue for processing.</p>
<p>The <strong>Validate</strong> stage dequeues intermediate objects, performs the validation
checks, and enqueues only valid objects for processing.</p>
<p>The <strong>Process</strong> stage dequeues intermediate objects and processes them.
There can be a pool of workers doing this in case the processing is very time-consuming.</p>
<p>This is amenable to asyncio, also. In that case, the final processing
would be a threadpool instead of a process pool. When using <code class="docutils literal notranslate"><span class="pre">ayncio</span></code> it’s
critical to avoid updates to shared data structures. In the rare case when
this is required, explicit locking will be required and can stall the async pipeline.</p>
</section>
<section id="file-naming-and-external-schema">
<h2>File Naming and External Schema<a class="headerlink" href="#file-naming-and-external-schema" title="Permalink to this headline">¶</a></h2>
<p>Some data management discipline is needed be sure that the schema and file match
up properly.  Naming conventions and standardized directory structures are
<em>essential</em> for working with external schema.</p>
<section id="well-known-formats">
<h3>Well Known Formats<a class="headerlink" href="#well-known-formats" title="Permalink to this headline">¶</a></h3>
<p>For well-known physical formats (<code class="file docutils literal notranslate"><span class="pre">.csv</span></code>, <code class="file docutils literal notranslate"><span class="pre">.xls</span></code>, <code class="file docutils literal notranslate"><span class="pre">.xlsx</span></code>, <code class="file docutils literal notranslate"><span class="pre">.xlsm</span></code>, <code class="file docutils literal notranslate"><span class="pre">.ods</span></code>,
<code class="file docutils literal notranslate"><span class="pre">.numbers</span></code>) the filename extension describes the physical format. Additional
information is required to determine the Logical Layout.</p>
<p>The schema may be loaded from column headers, in which case the binding is handled
via an embedded schema loader. If the  <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.HeadingRowSchemaLoader</span></code>
is used, no more information is required. If an external schema loader is used
(because the headings are not part of the sheet), then we must
bind each application to the appropriate external schema for a given file.</p>
<p>When the schema is external, the schema will often require a unique meta-schema.
This means a data file must be associated with a schema file and a schema loader
for the schema.</p>
<p>File naming rules don’t often work out for this, and some kind of explicit
configuration file may be required. In some cases, the directory structure
can be used to associate data files and schema files and meta-schema.</p>
</section>
<section id="fixed-formats-and-cobol">
<h3>Fixed Formats and COBOL<a class="headerlink" href="#fixed-formats-and-cobol" title="Permalink to this headline">¶</a></h3>
<p>For fixed-format files,
the filename extension does <strong>not</strong> describe the physical layout.
There is not widely-used extension for fixed-format files. A suffix like <code class="docutils literal notranslate"><span class="pre">.dat</span></code> is uninformative.
Making things slightly sompler, a fixed format schema combine logical layout and physical format into
a single description.</p>
<p>For fixed format files, the following conventions help
bind a file to its schema.</p>
<ul class="simple">
<li><p>The data file suffix should be the base name of a schema file.
For example, <code class="file docutils literal notranslate"><span class="pre">mydata.someschema</span></code> points to the <code class="file docutils literal notranslate"><span class="pre">someschema.cob</span></code> or
<code class="file docutils literal notranslate"><span class="pre">someschema.json</span></code> schema.</p></li>
<li><p>Schema files must be be either JSONSchema, a COBOL DDE file, or a
workbook in a well-known format. For example
<code class="file docutils literal notranslate"><span class="pre">someschema.cob</span></code> or <code class="file docutils literal notranslate"><span class="pre">someschema.xlsx</span></code>.</p></li>
</ul>
<p><strong>Examples</strong>.  We might see the following file names.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">september_2001</span><span class="o">.</span><span class="n">exchange_1</span>
<span class="n">november_2011</span><span class="o">.</span><span class="n">some_dde_name</span>
<span class="n">october_2011</span><span class="o">.</span><span class="n">some_dde_name</span>
<span class="n">exchange_1</span><span class="o">.</span><span class="n">xls</span>
<span class="n">some_dde_name</span><span class="o">.</span><span class="n">cob</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">september_2001.exchange_1</span></code> file is a fixed format file
which requires the <code class="docutils literal notranslate"><span class="pre">exchange_1.xls</span></code> metadata workbook. The metadata workbook should have
an easy-to-understand schema, ideally a heading row.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">november_2011.some_dde_name</span></code> and <code class="docutils literal notranslate"><span class="pre">october_2011.some_dde_name</span></code> files
are fixed format files which require the <code class="docutils literal notranslate"><span class="pre">some_dde_name.cob</span></code> metadata.</p>
</section>
<section id="external-schema-workbooks">
<h3>External Schema Workbooks<a class="headerlink" href="#external-schema-workbooks" title="Permalink to this headline">¶</a></h3>
<p>A workbook with an external schema sheet must adhere to a few conventions to be usable.
These rules form the basis for the <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.ExternalSchemaLoader</span></code>
class. To change the rules, extend that class.</p>
<p>The metaschema is defined in the class-level <code class="docutils literal notranslate"><span class="pre">META_SCHEMA</span></code> variable. This is a
JSONSchema definition with the following properties:</p>
<ul class="simple">
<li><p>The column names “name”, “description”, “dataType” are used.</p></li>
<li><p>Additional columns are allowed, but will be ignored.</p></li>
<li><p>Type definitions are the JSONSchema values: “string”, “number”, “integer”, and “boolean”.</p></li>
</ul>
<p>For simple column name changes, the <code class="docutils literal notranslate"><span class="pre">META_SCHEMA</span></code> can be replaced. For more complex changes,
the class will need to be extended.</p>
</section>
</section>
<section id="binding-a-schema-to-an-application">
<h2>Binding a Schema to an Application<a class="headerlink" href="#binding-a-schema-to-an-application" title="Permalink to this headline">¶</a></h2>
<p>We would like to be sure that our application’s expectations for a
schema are aligned with the schema actually present.
An application has several ways to bind its schema information.</p>
<ul class="simple">
<li><p><strong>Implicitly</strong>.  The code simply mentions specific columns
(either by name or position). If the schema definition doesn’t match the code
there will be run-time <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> exceptions.</p></li>
<li><p><strong>Explicitly</strong>. The code has a formal “requires” check to be sure
that the schema provided by the input file actually matches the
schema required by the application.</p></li>
</ul>
<p>The idea of explicit schema  parallels the configuration management issue of module
dependency. A data file can be said to <em>provide</em> a given schema and an
application <em>requires</em> a given schema.</p>
<p>An explicit check is far from fool proof. It’s – at best – a minimal confirmation
that an expected set of attributes are present.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">valid</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
    <span class="n">req</span> <span class="ow">in</span> <span class="n">schema</span> <span class="k">for</span> <span class="n">req</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;some&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;of&#39;</span><span class="p">,</span> <span class="s1">&#39;required&#39;</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This is essential when using a spreadsheets heading row as a schema.</p>
<p>A better approach is to have an expected schema. We can then compare the schema built by the heading
row with the expected schema. A heading row schema has no data type or conversion information,
making it inadequate for most applications.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">valid</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
    <span class="n">prop_name</span> <span class="ow">in</span> <span class="n">found_schema</span><span class="o">.</span><span class="n">properties</span> <span class="k">for</span> <span class="n">prop_name</span> <span class="ow">in</span> <span class="n">expected_schema</span><span class="o">.</span><span class="n">properties</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This assures us that the heading row schema found in the file includes the expected schema.
It may have additional columns, which will be ignored.</p>
<p>The more complete check is row-by-row data validation. This is often necessary.
We’ll turn to data validation below.</p>
</section>
<section id="schema-version-numbering">
<h2>Schema Version Numbering<a class="headerlink" href="#schema-version-numbering" title="Permalink to this headline">¶</a></h2>
<p>JSONSchema and XSD’s can have version numbers.  This is a very cool.</p>
<p>See <a class="reference external" href="http://www.xfront.com/Versioning.pdf">http://www.xfront.com/Versioning.pdf</a> for detailed discussion of how
to represent schema version information.</p>
<p>Databases, however, lack version numbering in the schema.  This leads to potential
compatibilty issues between application programs that expect version 3 of the
schema and an older database that implements version 2 of the schema.</p>
<p>Our file schema, similarly, don’t have a tidy, unambiguous numbering.</p>
<p>For external schema, we can embed the version in the file names.
We might want to use something like this <code class="docutils literal notranslate"><span class="pre">econometrics_vendor_1.2</span></code>.
This identifies the
generic type of data, the source for that file, and the schema version
number.</p>
<blockquote>
<div><p>Within a SQL database, we can easily use the schema name to carry
version information.  We could have a <code class="samp docutils literal notranslate"><span class="pre">name_</span><em><span class="pre">version</span></em></code> kind of
convention for the database schema objects that contain our tables.
This allows an application to confirm schema
compatibility with a trivial SQL query.</p>
</div></blockquote>
<p>For embedded schema in a spreadsheet, however, we have no <em>easy</em> way to provide schema identification
and version numbering.  We’re forced to
build an algorithm to examine the actual names in the embedded schema to deduce
the version.</p>
<p>This problem with embedded schema leads to using data profiling to reason out what the file is.
This may devolve to a manual examination
of the data profiling results to allow a human to determine the schema.
Then, once the schema has been identified, command-line options
can be used to bind the schema to file for correct processing.</p>
</section>
<section id="frequently-asked-questions">
<h2>Frequently Asked Questions<a class="headerlink" href="#frequently-asked-questions" title="Permalink to this headline">¶</a></h2>
<section id="junk-data">
<h3>Junk Data<a class="headerlink" href="#junk-data" title="Permalink to this headline">¶</a></h3>
<p>For inexplicable reasons, we can wind up with files that are damaged in some way.</p>
<blockquote>
<div><p>“there is a 65-byte “header” at the start of the file, what would be the best
(least hacky) way to skip over the first 65 bytes?”</p>
</div></blockquote>
<p>This is one of the reasons why use both a file name and an open file object as
arguments for opening a workbook.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;file_with_junk.some_schema&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">path</span><span class="o">.</span><span class="n">open</span><span class="p">(,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cobol</span><span class="p">:</span>
    <span class="n">cobol</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">66</span><span class="p">)</span>
    <span class="n">wb</span> <span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">COBOL_EBCDIC_File</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file_object</span><span class="o">=</span><span class="n">cobol</span><span class="p">)</span>
</pre></div>
</div>
<p>This skips past the junk.</p>
</section>
<section id="us-zip-codes">
<h3>US ZIP Codes<a class="headerlink" href="#us-zip-codes" title="Permalink to this headline">¶</a></h3>
<p>Spreadsheets turn US Zip codes into numbers, and the leading zeroes
get lost.</p>
<p>For this, we have conversion functions like <code class="docutils literal notranslate"><span class="pre">stingray.digits_5()</span></code> to
turn an integer into a 5-position string with leading zeroes.</p>
</section>
<section id="currency">
<h3>Currency<a class="headerlink" href="#currency" title="Permalink to this headline">¶</a></h3>
<p>Spreadsheets turn currency into floating-point numbers.
Any computation can lead to horrible ‘3.9999999997’ numbers instead of ‘4.00’.</p>
<p>For this se have a <code class="docutils literal notranslate"><span class="pre">stingray.decimal_2()</span></code> conversion function to
provide a decimal value rounded to two decimal places. When this is done
as early in the processing as possible, currency computations work out nicely.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Stingray_belon1553_small.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="index.html">Stingray-Reader</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design Considerations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Using <strong>Stingray Reader</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="demo/index.html">Demo Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="apidoc/index.html">stingray API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">Commercial Use</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="design.html" title="previous chapter">Design Considerations</a></li>
      <li>Next: <a href="demo/index.html" title="next chapter">Demo Applications</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, S.Lott.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/developer.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>