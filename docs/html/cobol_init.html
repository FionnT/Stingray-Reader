
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>10.2.1. COBOL Package – Extend Schema to Handle EBCDIC &#8212; The Stingray Schema-Based File Reader</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10.2.2. COBOL Loader Module – Parse COBOL Source to Load a Schema" href="cobol_loader.html" />
    <link rel="prev" title="10. The COBOL Package" href="cobol.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="cobol-package-extend-schema-to-handle-ebcdic">
<span id="cobol-init"></span><h1>10.2.1. COBOL Package – Extend Schema to Handle EBCDIC<a class="headerlink" href="#cobol-package-extend-schema-to-handle-ebcdic" title="Permalink to this headline">¶</a></h1>
<p>The COBOL package is a (large) Python <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> module which
includes much of the public API for working with COBOL files.</p>
<p>This module extends Stingray in several directions.</p>
<ul class="simple">
<li>A new <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Attribute</span></code></a> subclass, <a class="reference internal" href="#cobol.RepeatingAttribute" title="cobol.RepeatingAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute</span></code></a>.</li>
<li>A handy <a class="reference internal" href="#cobol.dump" title="cobol.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.dump()</span></code></a> function.</li>
<li>The hierarchy of classes based on <a class="reference internal" href="#cobol.COBOL_File" title="cobol.COBOL_File"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.COBOL_File</span></code></a> which provide
more sophisticated COBOL-based workbooks.</li>
</ul>
<p>Within the package we have the <a class="reference internal" href="cobol_loader.html#module-cobol.loader" title="cobol.loader"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cobol.loader</span></code></a> module which parses DDE’s
to create a schema.</p>
<div class="section" id="module-cobol">
<span id="module-overheads"></span><h2>10.2.1.1. Module Overheads<a class="headerlink" href="#module-cobol" title="Permalink to this headline">¶</a></h2>
<p>We depend on <a class="reference internal" href="cell.html#module-cell" title="cell"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cell</span></code></a>, <a class="reference internal" href="schema.html#module-schema" title="schema"><code class="xref py py-mod docutils literal notranslate"><span class="pre">schema</span></code></a>, and <a class="reference internal" href="workbook/init.html#module-workbook" title="workbook"><code class="xref py py-mod docutils literal notranslate"><span class="pre">workbook</span></code></a>.
We’ll also import one class definition from <a class="reference internal" href="cobol_defs.html#module-cobol.defs" title="cobol.defs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cobol.defs</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;stingray.cobol -- Extend the core Stingray definitions to handle COBOL</span>
<span class="sd">DDE&#39;s and COBOL files, including packed decimal and EBCDIC data.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">decimal</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">stingray.schema</span>
<span class="kn">import</span> <span class="nn">stingray.sheet</span>
<span class="kn">from</span> <span class="nn">stingray.workbook.fixed</span> <span class="k">import</span> <span class="n">Fixed_Workbook</span>


<span class="kn">from</span> <span class="nn">stingray.cobol.defs</span> <span class="k">import</span> <span class="n">TextCell</span>
</pre></div>
</div>
</div>
<div class="section" id="repeatingattribute-subclasses-of-attribute">
<h2>10.2.1.2. RepeatingAttribute Subclasses of Attribute<a class="headerlink" href="#repeatingattribute-subclasses-of-attribute" title="Permalink to this headline">¶</a></h2>
<p>Two new <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Attribute</span></code></a> subclasses are required to carry all the
additional attribute information developed during COBOL DDE parsing.</p>
<p>An attribute that has an <code class="docutils literal notranslate"><span class="pre">OCCURS</span></code> clause (or who’s parent has an <code class="docutils literal notranslate"><span class="pre">OCCURS</span></code> clause)
can accept an <a class="reference internal" href="#cobol.RepeatingAttribute.index" title="cobol.RepeatingAttribute.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute.index()</span></code></a> method to provide index values used to compute
effective offsets.</p>
<p>There are two variants.</p>
<ul class="simple">
<li>The initial, immutable, <a class="reference internal" href="#cobol.RepeatingAttribute" title="cobol.RepeatingAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute</span></code></a> as parsed.</li>
<li>A working <a class="reference internal" href="#cobol.IndexedAttribute" title="cobol.IndexedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.IndexedAttribute</span></code></a>. This is a subclass of
<a class="reference internal" href="#cobol.RepeatingAttribute" title="cobol.RepeatingAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute</span></code></a> and it contains partial or complete
indexing. Partial indexing means that a tuple is built by
<a class="reference internal" href="#cobol.COBOL_File.row_get" title="cobol.COBOL_File.row_get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.COBOL_File.row_get()</span></code></a>. Full indexing means that a single
<code class="docutils literal notranslate"><span class="pre">Cell</span></code> can be built.</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>http://yuml.me/diagram/scruffy;/class/
#cobol.attribute,
[Attribute]^[RepeatingAttribute],
[Schema]&lt;&gt;-[Attribute],
[Fixed_Workbook]-uses-&gt;[Attribute],
[Fixed_Workbook]^[COBOL_File],
[COBOL_File]-uses-&gt;[RepeatingAttribute].
</pre></div>
</div>
<img alt="_images/cobol_attribute.png" src="_images/cobol_attribute.png" />
<p>In order to fetch data for an ODO <code class="docutils literal notranslate"><span class="pre">OCCURS</span></code> element, the attribute offsets and sizes
cannot <strong>all</strong> be computed during parsing.
They must be computed lazily during data fetching. The <a class="reference internal" href="#cobol.ODO_LazyRow" title="cobol.ODO_LazyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.ODO_LazyRow</span></code></a>
class handles the Occurs Depending On situation.</p>
<p>Here are the attributes inherited from <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Attribute</span></code></a>.</p>
<dl class="attribute">
<dt id="cobol.name">
<code class="descclassname">cobol.</code><code class="descname">name</code><a class="headerlink" href="#cobol.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The attribute name. Typically always available for most kinds of schema.</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.create">
<code class="descclassname">cobol.</code><code class="descname">create</code><a class="headerlink" href="#cobol.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell class to create.  If omitted, the class-level
<code class="xref py py-data docutils literal notranslate"><span class="pre">Attribute.default_cell</span></code> will be used.
By default, this refers to <a class="reference internal" href="cell.html#cell.TextCell" title="cell.TextCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cell.TextCell</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.position">
<code class="descclassname">cobol.</code><code class="descname">position</code><a class="headerlink" href="#cobol.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional sequential position. This is set by the <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Schema</span></code></a>
that contains this object.</p>
</dd></dl>

<p>The additional values commonly provided by simple fixed format file schemata.
These can’t be treated as simple values, however, since they’re
clearly changed based on the ODO issues.</p>
<dl class="attribute">
<dt id="cobol.size">
<code class="descclassname">cobol.</code><code class="descname">size</code><a class="headerlink" href="#cobol.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size within the buffer.</p>
</dd></dl>

<p>These two properties over overridden by the <a class="reference internal" href="#cobol.IndexedAttribute" title="cobol.IndexedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.IndexedAttribute</span></code></a> subclass;
this is created by the <a class="reference internal" href="#cobol.RepeatingAttribute.index" title="cobol.RepeatingAttribute.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute.index()</span></code></a> method.
The superclass versions are simple a delegation to the DDE.
If <a class="reference internal" href="#cobol.RepeatingAttribute.index" title="cobol.RepeatingAttribute.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute.index()</span></code></a> is used, the subclass object is built
where these values come from the <code class="docutils literal notranslate"><span class="pre">index</span></code> method results.</p>
<dl class="attribute">
<dt id="cobol.dimensionality">
<code class="descclassname">cobol.</code><code class="descname">dimensionality</code><a class="headerlink" href="#cobol.dimensionality" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple of DDE’s that defines the dimensionality pushed down to this
item through the COBOL DDE hierarchy.</p>
<p>This meay be set by the <a class="reference internal" href="#cobol.RepeatingAttribute.index" title="cobol.RepeatingAttribute.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute.index()</span></code></a> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.offset">
<code class="descclassname">cobol.</code><code class="descname">offset</code><a class="headerlink" href="#cobol.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional offset into a buffer. This may be statically defined,
or it may be dynamic because of variably-located data supporting
the Occurs Depends On.</p>
<p>This meay be set by the <a class="reference internal" href="#cobol.RepeatingAttribute.index" title="cobol.RepeatingAttribute.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute.index()</span></code></a> method.</p>
</dd></dl>

<p>This subclass introduces yet more attribute-like properties that simply
delegate to the DDE.</p>
<dl class="attribute">
<dt id="cobol.dde">
<code class="descclassname">cobol.</code><code class="descname">dde</code><a class="headerlink" href="#cobol.dde" title="Permalink to this definition">¶</a></dt>
<dd><p>A weakref to a <a class="reference internal" href="cobol_defs.html#cobol.defs.DDE" title="cobol.defs.DDE"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.DDE</span></code></a> object.</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.path">
<code class="descclassname">cobol.</code><code class="descname">path</code><a class="headerlink" href="#cobol.path" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code>-separated path from top-level name to this element’s name.</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.usage">
<code class="descclassname">cobol.</code><code class="descname">usage</code><a class="headerlink" href="#cobol.usage" title="Permalink to this definition">¶</a></dt>
<dd><p>The original DDE.usage object, an instance of <a class="reference internal" href="cobol_defs.html#cobol.defs.Usage" title="cobol.defs.Usage"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.Usage</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.redefines">
<code class="descclassname">cobol.</code><code class="descname">redefines</code><a class="headerlink" href="#cobol.redefines" title="Permalink to this definition">¶</a></dt>
<dd><p>The original DDE.allocation object, an instance of <a class="reference internal" href="cobol_defs.html#cobol.defs.Allocation" title="cobol.defs.Allocation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.Allocation</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.picture">
<code class="descclassname">cobol.</code><code class="descname">picture</code><a class="headerlink" href="#cobol.picture" title="Permalink to this definition">¶</a></dt>
<dd><p>The original DDE.picture object, an instance of <a class="reference internal" href="cobol_loader.html#cobol.loader.Picture" title="cobol.loader.Picture"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.Picture</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.size_scale_precision">
<code class="descclassname">cobol.</code><code class="descname">size_scale_precision</code><a class="headerlink" href="#cobol.size_scale_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>The original DDE.sizeScalePrecision object, a tuple with size, scale and precision derived
from the picture.</p>
</dd></dl>

<dl class="class">
<dt id="cobol.RepeatingAttribute">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">RepeatingAttribute</code><a class="headerlink" href="#cobol.RepeatingAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>An attribute with dimensionality. Not all COBOL items repeat.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RepeatingAttribute</span><span class="p">(</span> <span class="n">stingray</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">Attribute</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An attribute with dimensionality. Not all COBOL items repeat.</span>

<span class="sd">    An &quot;OCCURS&quot; clause will define repeating values.</span>
<span class="sd">    An &quot;OCCURS DEPENDING ON&quot; clause may define variably located values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">default_cell</span><span class="o">=</span> <span class="n">TextCell</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dde</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="o">=</span> <span class="n">dde</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">create</span><span class="p">,</span> <span class="n">position</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_cell</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s2">&quot;Offset </span><span class="si">{0}</span><span class="s2"> is ignored; </span><span class="si">{1}</span><span class="s2"> used&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">offset</span><span class="p">),</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">kw</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="n">dim</span><span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">repr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Attribute( name=</span><span class="si">{0.name!r}</span><span class="s2">, position=</span><span class="si">{0.position}</span><span class="s2">, offset=</span><span class="si">{0.offset}</span><span class="s2">, size=</span><span class="si">{0.size}</span><span class="s2">, dimensionality=(</span><span class="si">{1}</span><span class="s2">) )&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.RepeatingAttribute.index">
<code class="descclassname">RepeatingAttribute.</code><code class="descname">index</code><span class="sig-paren">(</span><em>*values</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.RepeatingAttribute.index" title="Permalink to this definition">¶</a></dt>
<dd><p>If the number of index values matches the dimensionality, we’ll return a tweaked
attribute which has just the offset required and a dimensionality of <code class="docutils literal notranslate"><span class="pre">tuple()</span></code>.</p>
<p>If the number of index values is insufficient, we’ll return a tweaked attribute
with which has the starting offset and the dimensions left otherwise unspecified.</p>
<p>If the number of index values is excessive, we’ll attempt to pop from an empty
list.</p>
<p>Note that <a class="reference internal" href="#cobol.RepeatingAttribute.index" title="cobol.RepeatingAttribute.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute.index()</span></code></a> is applied incrementally when the application supplies some
of the indices.</p>
<ul class="simple">
<li>First, an application can supply some of the indices, creating
<a class="reference internal" href="#cobol.IndexedAttribute" title="cobol.IndexedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.IndexedAttribute</span></code></a> with an initial offset.</li>
<li>Second, the <a class="reference internal" href="#cobol.COBOL_File" title="cobol.COBOL_File"><code class="xref py py-class docutils literal notranslate"><span class="pre">COBOL_File</span></code></a> will supply any remaining indices,
creating yet more temporary  <a class="reference internal" href="#cobol.IndexedAttribute" title="cobol.IndexedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.IndexedAttribute</span></code></a> based on the initial offset.</li>
</ul>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">index</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;Apply possibly incomplete index values to an attribute.</span>
<span class="sd">    We do this by cloning this attribute and setting a modified</span>
<span class="sd">    dimensionality and offset.</span>

<span class="sd">    :param values: 0-based index values.  Yes, legacy COBOL language is 1-based.</span>
<span class="sd">        For Python applications, zero-based makes more sense.</span>
<span class="sd">    :returns: A :py:class:`cobol.IndexedAttribute` copy, with modified offset</span>
<span class="sd">    and dimensionality that can be used with :py:meth:`COBOL_File.row_get`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">values</span><span class="p">,</span> <span class="s2">&quot;Missing index values&quot;</span>
    <span class="c1"># Original values for a RepeatingAttribute</span>
    <span class="c1"># Modified values for an IndexedAttribute</span>
    <span class="n">offset</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">dim_list</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">)</span>
    <span class="c1"># Apply given index values.</span>
    <span class="n">val_list</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">val_list</span><span class="p">:</span>
        <span class="n">index</span><span class="o">=</span> <span class="n">val_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dim</span><span class="o">=</span> <span class="n">dim_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">dim</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">index</span>
    <span class="c1"># Build new subclass object with indexes applied.</span>
    <span class="n">clone</span><span class="o">=</span> <span class="n">IndexedAttribute</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dim_list</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">clone</span>
</pre></div>
</div>
<p>With this, a <code class="docutils literal notranslate"><span class="pre">row.cell(schema.get('name').index(i))</span></code> will compute a proper offset.</p>
<p>We “clone” the attribute to assure that each time we apply (or don’t apply)
the index, nothing stateful will have happened to the original immutable attribute
definition.</p>
<p>Note that an incomplete set of index values forces the underlying
workbook to create a Python tuple (or tuple of tuples) structure to
contain all the requested values. See <a class="reference internal" href="#cobol.COBOL_File.row_get" title="cobol.COBOL_File.row_get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.COBOL_File.row_get()</span></code></a>.</p>
<p>The additional properties which are simply shortcuts so that a
generic <a class="reference internal" href="#cobol.RepeatingAttribute" title="cobol.RepeatingAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute</span></code></a> has access to the DDE details.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@property</span>
<span class="k">def</span> <span class="nf">dimensionality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;tuple of parent DDE&#39;s. Baseline value; no indexes applied.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">dimensionality</span>
<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Baseline value; no indexes applied.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">offset</span>
<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">pathTo</span><span class="p">()</span>
<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">usage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">usage</span>
<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">redefines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">allocation</span>
<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">picture</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">picture</span>
<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">size_scale_precision</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">sizeScalePrecision</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.IndexedAttribute">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">IndexedAttribute</code><a class="headerlink" href="#cobol.IndexedAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>The IndexedAttribute is a subclass of <a class="reference internal" href="#cobol.RepeatingAttribute" title="cobol.RepeatingAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute</span></code></a>
with (some) indices applied. Since this inherits the <a class="reference internal" href="#cobol.RepeatingAttribute.index" title="cobol.RepeatingAttribute.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute.index()</span></code></a>
method, we can apply indices incrementally.</p>
<p>This class is not built directly, but only created by <a class="reference internal" href="#cobol.RepeatingAttribute.index" title="cobol.RepeatingAttribute.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.RepeatingAttribute.index()</span></code></a>
with some (or all) indices applied.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IndexedAttribute</span><span class="p">(</span> <span class="n">RepeatingAttribute</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An attribute with dimensionality and indexes applied.</span>
<span class="sd">    This must be built from a :py:class:`cobol.RepeatingAttribute`. It will copy</span>
<span class="sd">    some attributes in an effort to somewhat improve efficiency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">default_cell</span><span class="o">=</span> <span class="n">TextCell</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dimensionality</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">dde</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">create</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimensionality</span><span class="o">=</span> <span class="n">dimensionality</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;tuple of DDE&#39;s; Set by ``attribute.index()``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensionality</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set by ``attribute.index()``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>
</pre></div>
</div>
</div>
<div class="section" id="cobol-lazyrow">
<h2>10.2.1.3. COBOL LazyRow<a class="headerlink" href="#cobol-lazyrow" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="sheet.html#sheet.LazyRow" title="sheet.LazyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">sheet.LazyRow</span></code></a> class is blissfully unaware of the need to compute
sizes and offsets for COBOL.</p>
<dl class="class">
<dt id="cobol.ODO_LazyRow">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">ODO_LazyRow</code><a class="headerlink" href="#cobol.ODO_LazyRow" title="Permalink to this definition">¶</a></dt>
<dd><p>This subclass of <a class="reference internal" href="sheet.html#sheet.LazyRow" title="sheet.LazyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">sheet.LazyRow</span></code></a> to provide add the feature to recompute sizes
and offsets in the case of a variable-located DDE due to an Occurs Depending On.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ODO_LazyRow</span><span class="p">(</span> <span class="n">stingray</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">LazyRow</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If the DDE is variably-located, tweak the sizes and offsets.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">sheet</span><span class="p">,</span> <span class="o">**</span><span class="n">state</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build the row from the bytes.</span>

<span class="sd">        :param sheet: the containing sheet.</span>
<span class="sd">        :param **state: worksheet-specific state value to save.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span> <span class="n">sheet</span><span class="p">,</span> <span class="o">**</span><span class="n">state</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">dde</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dde&#39;</span><span class="p">,[]):</span>
            <span class="k">if</span> <span class="n">dde</span><span class="o">.</span><span class="n">variably_located</span><span class="p">:</span>
                <span class="n">dde</span><span class="o">.</span><span class="n">setSizeAndOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">totalSize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="dump-a-record">
<h2>10.2.1.4. Dump a Record<a class="headerlink" href="#dump-a-record" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cobol.dump_iter">
<code class="descclassname">cobol.</code><code class="descname">dump_iter</code><span class="sig-paren">(</span><em>aDDE</em>, <em>aRow</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.dump_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>To support dumping raw data from a record, this will iterate through all items
in an original DDE. It will a five-tuple with (dde, attribute, indices, bytes, Cell)
for each DDE.</p>
<p>If the DDE does not have an OCCURS clause, the indices will be an empty tuple.
Otherwise, each individual combination will be yielded. For big, nested tables, this
may turn out to be a lot of combinations.</p>
<p>The bytes is the raw bytes for non-FILLER and non-group elements.</p>
<p>The Cell will be a Cell object, either with valid data or an <a class="reference internal" href="cobol_defs.html#cobol.defs.ErrorCell" title="cobol.defs.ErrorCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.ErrorCell</span></code></a>.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dump_iter</span><span class="p">(</span> <span class="n">aDDE</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Yields iterator over tuples of (dde, attribute, indices, bytes, Cell)&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span> <span class="n">dimensionality</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="p">()</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dimensionality</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">partial</span>
            <span class="k">return</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">dimensionality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rest</span><span class="o">=</span> <span class="n">dimensionality</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expand_dims</span><span class="p">(</span> <span class="n">rest</span><span class="p">,</span> <span class="n">partial</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="p">,)</span> <span class="p">):</span>
                <span class="k">yield</span> <span class="n">e</span>
    <span class="n">attr</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">attribute</span><span class="p">()</span> <span class="c1"># Final size and offset details</span>
    <span class="k">if</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">expand_dims</span><span class="p">(</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">dimensionality</span> <span class="p">):</span>
            <span class="k">yield</span> <span class="n">aDDE</span><span class="p">,</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">attribute</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">aRow</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">aRow</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="n">indices</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">picture</span> <span class="ow">and</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;FILLER&quot;</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">aDDE</span><span class="p">,</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">attribute</span><span class="p">(),</span> <span class="p">(),</span> <span class="n">aRow</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">aRow</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># FILLER or group level without a picture: no data is available</span>
        <span class="k">yield</span> <span class="n">aDDE</span><span class="p">,</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">attribute</span><span class="p">,</span> <span class="p">(),</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="c1">#pprint.pprint( child )</span>
        <span class="k">for</span> <span class="n">details</span> <span class="ow">in</span> <span class="n">dump_iter</span><span class="p">(</span> <span class="n">child</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">):</span>
            <span class="k">yield</span> <span class="n">details</span>
</pre></div>
</div>
<dl class="function">
<dt id="cobol.dump">
<code class="descclassname">cobol.</code><code class="descname">dump</code><span class="sig-paren">(</span><em>schema</em>, <em>row</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump data from a record, driven by the original DDE structure.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span> <span class="n">schema</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">{:45s}</span><span class="s2"> </span><span class="si">{:3s}</span><span class="s2"> </span><span class="si">{:3s}</span><span class="s2"> </span><span class="si">{!s}</span><span class="s2"> </span><span class="si">{!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;Field&quot;</span><span class="p">,</span> <span class="s2">&quot;Pos&quot;</span><span class="p">,</span> <span class="s2">&quot;Sz&quot;</span><span class="p">,</span> <span class="s2">&quot;Raw&quot;</span><span class="p">,</span> <span class="s2">&quot;Cell&quot;</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">schema</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;dde&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">aDDE</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">raw_bytes</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">dump_iter</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">aRow</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">{:45s}</span><span class="s2"> </span><span class="si">{:3d}</span><span class="s2"> </span><span class="si">{:3d}</span><span class="s2"> </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">aDDE</span><span class="o">.</span><span class="n">indent</span><span class="o">*</span><span class="s1">&#39;  &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">aDDE</span><span class="p">),</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="n">raw_bytes</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="cobol-workbook-files">
<h2>10.2.1.5. COBOL “Workbook” Files<a class="headerlink" href="#cobol-workbook-files" title="Permalink to this headline">¶</a></h2>
<p>A COBOL file is – in effect – a single-sheet workbook with an external schema.
It looks, then, a lot like <a class="reference internal" href="workbook/fixed.html#workbook.Fixed_Workbook" title="workbook.Fixed_Workbook"><code class="xref py py-class docutils literal notranslate"><span class="pre">workbook.Fixed_Workbook</span></code></a>.</p>
<ul class="simple">
<li>A pure character file, encoded UNICODE characters in some standard encoding
like UTF-8 or UTF-16.  This cannot include COMP or COMP-3 fields because
the codec would make a mess of the bit patterns.</li>
<li>An EBCDIC-encoded byte file.  This can include COMP or COMP-3 fields.</li>
<li>An ASCII-encoded byte file.  This can include COMP or COMP-3 fields.
While this may exist, it seems to be very rare. We don’t implement it.</li>
</ul>
<p>Note that each cell creation involves two features. This leads to a kind of <strong>Double Dispatch</strong> algorithm.</p>
<ul class="simple">
<li>The cell type.  <a class="reference internal" href="cobol_defs.html#cobol.defs.TextCell" title="cobol.defs.TextCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.TextCell</span></code></a>,
<a class="reference internal" href="cobol_defs.html#cobol.defs.NumberDisplayCell" title="cobol.defs.NumberDisplayCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.NumberDisplayCell</span></code></a>,
<a class="reference internal" href="cobol_defs.html#cobol.defs.NumberComp3Cell" title="cobol.defs.NumberComp3Cell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.NumberComp3Cell</span></code></a> or <a class="reference internal" href="cobol_defs.html#cobol.defs.NumberCompCell" title="cobol.defs.NumberCompCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.NumberCompCell</span></code></a>.</li>
<li>The workbook encoding type.  Character or EBCDIC (or ASCII).</li>
</ul>
<p>The issue here is we’re stuck with a complex “double-dispatch” problem.
Each workbook subclass needs to implement methods for <code class="docutils literal notranslate"><span class="pre">get_text</span></code>, <code class="docutils literal notranslate"><span class="pre">number_display</span></code>,
<code class="docutils literal notranslate"><span class="pre">number_comp</span></code> and <code class="docutils literal notranslate"><span class="pre">number_comp3</span></code>.</p>
<p>The conversions, while tied to the workbook encoding, aren’t properly tied to
stateful sheet and row processing in the workbook.  They’re just bound to the
encoding.  Consequently, we can make them static methods, possibly even
making this a mixin strategy.</p>
<p>The common use case looks like this.</p>
<ol class="arabic simple">
<li>The application uses <code class="code docutils literal notranslate"><span class="pre">row.cell(</span> <span class="pre">schema[n]</span> <span class="pre">)</span></code> to fetch a <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cell.Cell</span></code></a>.
The <code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.ODO_LazyRow.cell()</span></code> method is simply <code class="docutils literal notranslate"><span class="pre">sheet.workbook.row_get(</span> <span class="pre">buffer,</span> <span class="pre">attribute</span> <span class="pre">)</span></code>.
It applies the cell type (via the schema item’s attribute) and the raw data in the row’s buffer.</li>
<li>The workbook <code class="docutils literal notranslate"><span class="pre">row_get(</span> <span class="pre">buffer,</span> <span class="pre">attribute</span> <span class="pre">)</span></code> has to do the following.<ul>
<li>Convert the buffer into a proper value based on the <code class="docutils literal notranslate"><span class="pre">attribute</span></code> type
information <strong>and</strong> the worksheet-specific methods for unpacking the
various types of data.  The various <a class="reference internal" href="#module-cobol" title="cobol"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cobol</span></code></a> Cell subclasses
can refer to the proper conversion methods.</li>
<li>Create the required <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cell.Cell</span></code></a> based on the <code class="docutils literal notranslate"><span class="pre">attribute.create</span></code> function.
See <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Attribute</span></code></a>.</li>
</ul>
</li>
</ol>
<p>There’s a less common use case to extract a subset of row bytes to populate a
separate 01-level definition that’s not tied to the Workbook’s schema.</p>
<ol class="arabic simple">
<li>The application uses <code class="docutils literal notranslate"><span class="pre">subrow=</span> <span class="pre">row.data(</span> <span class="pre">schema[n],</span> <span class="pre">other_schema</span> <span class="pre">)</span></code> to fetch some bytes that can
be used to create a new LazyRow tied to a different schema.</li>
<li>The application uses <code class="docutils literal notranslate"><span class="pre">subrow.cell(</span> <span class="pre">subschema[m]</span> <span class="pre">)</span></code> to fetch a <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cell.Cell</span></code></a>.
This doesn’t go back to the original workbook, it goes to this “subrow” of the
workbook.</li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>http://yuml.me/diagram/scruffy;/class/
#cobol,
[Fixed_Workbook]^[COBOL_File],
[COBOL_File]^[Character_File],
[COBOL_File]^[EBCDIC_File].
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/cobol_file.png"><img alt="_images/cobol_file.png" src="_images/cobol_file.png" style="width: 6in;" /></a>
<div class="section" id="cobol-file">
<h3>10.2.1.5.1. COBOL File<a class="headerlink" href="#cobol-file" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cobol.COBOL_File">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">COBOL_File</code><a class="headerlink" href="#cobol.COBOL_File" title="Permalink to this definition">¶</a></dt>
<dd><p>This class introduces the expanded version of <code class="docutils literal notranslate"><span class="pre">row_get</span></code> that honors
a schema attribute with dimensionality.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">COBOL_File</span><span class="p">(</span> <span class="n">Fixed_Workbook</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL &quot;workbook&quot; file which uses  :py:class:`cobol.RepeatingAttribute` and</span>
<span class="sd">    creates COBOL Cell values.  This is an abstraction which</span>
<span class="sd">    lacks specific decoding methods.</span>

<span class="sd">    This is a :py:class:`Fixed_Workbook`: a file with fixed-sized, no-punctuation fields.</span>
<span class="sd">    A schema is required to parse the attributes.</span>

<span class="sd">    The rows are defined as :py:class:`cobol.ODO_LazyRow` instances so that</span>
<span class="sd">    bad data can be gracefully skipped over and Occurs Depending On offsets</span>
<span class="sd">    can be properly calculated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">row_class</span><span class="o">=</span> <span class="n">ODO_LazyRow</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.COBOL_File.row_get_index">
<code class="descclassname">COBOL_File.</code><code class="descname">row_get_index</code><span class="sig-paren">(</span><em>row</em>, <em>attr</em>, <em>*index</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.COBOL_File.row_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returning a particular Cell from a row, however, is more interesting for COBOL
because the Attribute may contains an “OCCURS” clause.  In which case, we may need
to assemble a tuple of values.</p>
<p>If there is dimensionality, then take the top-level dimension (<code class="docutils literal notranslate"><span class="pre">dim[0]</span></code>) and
use it as an iterator to fetch data based on the rest of the dimensions (<code class="docutils literal notranslate"><span class="pre">dim[1:]</span></code>).</p>
<p>This can assemble a recursive tuple-of-tuples if there are multiple levels
of dimensionality.</p>
<p>If too few index values are provided, a tuple of results is built around the missing values.</p>
<p>If enough values are provided, a single result object will be built.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Performance</p>
<p class="last">This is the most-used method. Removing the if-statement would be
a huge improvement.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">row_get_index</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="o">*</span><span class="n">index</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Emit a nested-tuple structure of Cell values using the given index values.</span>
<span class="sd">    :param row: the source Row.</span>
<span class="sd">    :param attr: the  :py:class:`cobol.RepeatingAttribute`</span>
<span class="sd">        with the original tuple of dimensions,</span>
<span class="sd">        or a :py:class:`cobol.IndexedAttribute` which has</span>
<span class="sd">        an offset and partial dimensions.</span>
<span class="sd">    :param index: optional tuple of index values to use.</span>
<span class="sd">        Instead of ``row_get( schema.get(&#39;name&#39;).index(i) )``</span>
<span class="sd">        we can use ``row_get_index( schema.get(&#39;name&#39;), i )``</span>
<span class="sd">    :returns: a (possibly nested) tuple of Cell values matching the dims that lacked</span>
<span class="sd">        index values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">dimensionality</span> <span class="ow">and</span> <span class="n">index</span><span class="p">:</span>
        <span class="c1"># ``attr.index()`` probably not previously used.</span>
        <span class="c1"># Apply all remaining values and get the resulting item.</span>
        <span class="n">final</span><span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="o">*</span><span class="n">index</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_get</span><span class="p">(</span> <span class="n">row</span><span class="p">,</span> <span class="n">final</span> <span class="p">)</span>
    <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
        <span class="c1"># ``attr.index()`` previously used with partial arg values.</span>
        <span class="c1"># Build composite result.</span>
        <span class="n">d</span><span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">occurs</span><span class="o">.</span><span class="n">number</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">result</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">sub</span><span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_get</span><span class="p">(</span> <span class="n">row</span><span class="p">,</span> <span class="n">sub</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Doesn&#39;t belong here, delegate.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_get</span><span class="p">(</span> <span class="n">row</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.COBOL_File.row_get">
<code class="descclassname">COBOL_File.</code><code class="descname">row_get</code><span class="sig-paren">(</span><em>row</em>, <em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.COBOL_File.row_get" title="Permalink to this definition">¶</a></dt>
<dd><p>The API method will get data from a row described by an attribute.
If the attribute has dimensions, then indices are used or multiple values are returned
by <a class="reference internal" href="#cobol.COBOL_File.row_get_index" title="cobol.COBOL_File.row_get_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.COBOL_File.row_get_index()</span></code></a>.</p>
<p>If the attribute is has no dimensions, then it’s simply pulled from the source row.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Performance</p>
<p class="last">This is the most-used method. Removing the if-statement would be
a huge improvement.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">row_get</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a Cell(s) from the row&#39;s data.</span>
<span class="sd">    :param row: The current Row</span>
<span class="sd">    :param attr: The desired Attribute; possibly tweaked to</span>
<span class="sd">        have an offset and partial dimensions. Or possibly the original.</span>
<span class="sd">    :returns: A single Cell or a nested tuple of Cells if indexes</span>
<span class="sd">        were not provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_get_index</span><span class="p">(</span> <span class="n">row</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extract</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">_state</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">attr</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span><span class="n">attr</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="n">attr</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">create</span><span class="p">(</span> <span class="n">extract</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
<p>Note that this depends on the superclass, which depends ordinary Unicode/ASCII line breaks.
This will not work for EBCDIC files, which may lack appropriate line break characters.
For that, we’ll need to use specific physical format parsing helpers based on the
Z/OS RECFM parameter used to define the file.</p>
<dl class="method">
<dt id="cobol.COBOL_File.subrow">
<code class="descclassname">COBOL_File.</code><code class="descname">subrow</code><span class="sig-paren">(</span><em>subschema</em>, <em>text_cell</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.COBOL_File.subrow" title="Permalink to this definition">¶</a></dt>
<dd><p>In some COBOL files, there can be 01-level “subrecords” buried within an 01-level record.</p>
<p>We can use <code class="docutils literal notranslate"><span class="pre">wb.subrow(subschema,</span> <span class="pre">row.cell(schema_header_dict['GENERIC-FIELD']))</span></code>
to map a particular field (‘GENERIC-FIELD’) to an entire 01-level schema, creating
a “subrow” from a single field within the parent row.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">subrow</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subschema</span><span class="p">,</span> <span class="n">text_cell</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Build a row-like object from a single field.</span>

<span class="sd">    :param subschema: a schema built from an 01-level DDE.</span>
<span class="sd">    :param text_cell: a specific text cell to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_class</span><span class="p">(</span>
        <span class="n">stingray</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">ExternalSchemaSheet</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">subschema</span> <span class="p">),</span>
        <span class="n">data</span><span class="o">=</span> <span class="n">text_cell</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">subrow</span>
</pre></div>
</div>
</div>
<div class="section" id="character-file">
<h3>10.2.1.5.2. Character File<a class="headerlink" href="#character-file" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cobol.Character_File">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">Character_File</code><a class="headerlink" href="#cobol.Character_File" title="Permalink to this definition">¶</a></dt>
<dd><p>This is subclass of <a class="reference internal" href="#cobol.COBOL_File" title="cobol.COBOL_File"><code class="xref py py-class docutils literal notranslate"><span class="pre">COBOL_File</span></code></a> that handles COBOL data parsing
where the underlying file is text. Since the file is text, Python handles
any OS-level bytes-to-text conversions.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Character_File</span><span class="p">(</span> <span class="n">COBOL_File</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL &quot;workbook&quot; file with decoding functions for</span>
<span class="sd">    proper character data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>The following functions are used to do data conversions for COBOL Character files.
Text is easy, Python’s <code class="docutils literal notranslate"><span class="pre">io.open</span></code> has already handled this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">text</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract a text field&#39;s value.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">buffer</span>
</pre></div>
</div>
<p>Numeric data with usage <code class="docutils literal notranslate"><span class="pre">DISPLAY</span></code> is essentially text. In some cases, the
picture has <code class="docutils literal notranslate"><span class="pre">V</span></code>, which means that we must handle this implicit decimal point.
The “display” feature is the COBOL default: everything is plain text.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The core rule for character files</p>
<p>Leading separate sign is the default for character files.</p>
<p class="last">COBOL can support other kinds of signs. This conversion doesn’t.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">number_display</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract a numeric field&#39;s value.</span>
<span class="sd">    Based on leading, separate sign.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">final</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="n">dec_sign</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">size_scale_precision</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">display</span><span class="o">=</span><span class="n">buffer</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">precision</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dec_sign</span> <span class="o">==</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span>
            <span class="n">display</span><span class="o">=</span> <span class="n">display</span><span class="p">[:</span><span class="o">-</span><span class="n">precision</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">display</span><span class="p">[</span><span class="o">-</span><span class="n">precision</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span> <span class="n">display</span> <span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">Character_File</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span> <span class="s2">&quot;Can&#39;t process </span><span class="si">{0!r}</span><span class="s2"> from </span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">display</span><span class="p">,</span><span class="n">buffer</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">raise</span>
</pre></div>
</div>
<p>COMP-3 in proper character files may not make any sense at all.
A codec would make a hash of the bit patterns required.
However, we’ve defined the method here so that it can be used by the EBCDIC subclass
trivially.</p>
<p>We’re going to build an ASCII version of the number by decoding the bytes into
a mutable bytearray and decorating them with decimal point and sign. This is
demonstrably faster and avoids object creation to the extent possible.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span> <span class="n">buffer</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Include &#39; &#39; position for leading sign character.</span>
<span class="sd">    Trailing sign field will be 48+0xd for negative.</span>
<span class="sd">    48+0xf is &quot;unsigned&quot; and 48+0xc is positive.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">yield</span> <span class="mi">32</span> <span class="c1"># ord(b&#39; &#39;)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
        <span class="k">yield</span> <span class="mi">48</span><span class="o">+</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># ord(b&#39;0&#39;)</span>
        <span class="k">yield</span> <span class="mi">48</span><span class="o">+</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mh">0x0f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">number_comp3</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode comp-3, packed decimal values.</span>

<span class="sd">    Each byte is two decimal digits.</span>

<span class="sd">    Last byte has a digit plus sign information: 0xd is &lt;0, 0xf is unsigned, and 0xc &gt;=0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">final</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="n">dec_sign</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">size_scale_precision</span>
    <span class="c1">#print( repr(buffer), &quot;from&quot;, repr(display) )</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span> <span class="n">Character_File</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span> <span class="n">buffer</span> <span class="p">)</span> <span class="p">)</span>
    <span class="c1"># Proper sign in front; replace trailing sign with space.</span>
    <span class="n">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="mi">45</span> <span class="k">if</span> <span class="n">digits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">48</span><span class="o">+</span><span class="mh">0xd</span> <span class="k">else</span> <span class="mi">32</span> <span class="c1"># ord(b&#39;-&#39;), ord(b&#39; &#39;)</span>
    <span class="n">digits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mi">32</span> <span class="c1"># ord(&#39; &#39;)</span>
    <span class="c1"># Add decimal place if needed.</span>
    <span class="k">if</span> <span class="n">precision</span><span class="p">:</span>
        <span class="n">digits</span><span class="p">[</span><span class="o">-</span><span class="n">precision</span><span class="p">:]</span><span class="o">=</span> <span class="n">digits</span><span class="p">[</span><span class="o">-</span><span class="n">precision</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Shift digits to right.</span>
        <span class="n">digits</span><span class="p">[</span><span class="o">-</span><span class="n">precision</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mi">46</span> <span class="c1"># Insert ord(b&#39;.&#39;)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span> <span class="n">digits</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ASCII&quot;</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">Character_File</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span> <span class="s2">&quot;Can&#39;t process </span><span class="si">{0!r}</span><span class="s2"> from </span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span><span class="n">buffer</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">raise</span>
</pre></div>
</div>
<p>COMP in proper character files may not make any sense, either.
A codec would make a hash of the bit patterns required.
Again, we’ve defined it here because that’s relatively simple to extend.</p>
<p>We’re simply going to unpack big-endian bytes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">number_comp</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode comp, binary values.&quot;&quot;&quot;</span>
    <span class="n">final</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="n">dec_sign</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">size_scale_precision</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">sc</span><span class="p">,</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="s1">&#39;&gt;h&#39;</span><span class="p">,</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">:</span>
        <span class="n">sc</span><span class="p">,</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="s1">&#39;&gt;i&#39;</span><span class="p">,</span> <span class="mi">4</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sc</span><span class="p">,</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="s1">&#39;&gt;q&#39;</span><span class="p">,</span> <span class="mi">8</span>
    <span class="n">n</span><span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span> <span class="n">sc</span><span class="p">,</span> <span class="n">buffer</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Class-level logger</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Character_File</span><span class="o">.</span><span class="n">log</span><span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span> <span class="n">Character_File</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ebcdic-file">
<h3>10.2.1.5.3. EBCDIC File<a class="headerlink" href="#ebcdic-file" title="Permalink to this headline">¶</a></h3>
<p>The EBCDIC files require specific physical “Record Format” (RECFM) assistance.
These classes define a number of Z/OS RECFM conversion. We recognize four
actual RECFM’s plus an additional special case.</p>
<ul class="simple">
<li>F - Fixed.</li>
<li>FB - Fixed Blocked.</li>
<li>V - Variable, data must have the RDW word preserved.</li>
<li>VB - Variable Blocked, data must have BDW and RDW words.</li>
<li>N - Variable, but no BDW or RDW words. This involves some buffer management
magic to recover the records properly.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">IBM z/Architecture mainframes are all big-endian</p>
</div>
<dl class="class">
<dt id="cobol.RECFM_Parser">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">RECFM_Parser</code><a class="headerlink" href="#cobol.RECFM_Parser" title="Permalink to this definition">¶</a></dt>
<dd><p>This class hierarchy breaks up EBCDIC files into records.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RECFM_Parser</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Parse a physical file format.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">record_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return each physical record, stripped of headers.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">used</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of bytes actually consumed.</span>
<span class="sd">        Only really relevant for RECFM_N subclass to handle variable-length</span>
<span class="sd">        records with no RDW/BDW overheads.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.RECFM_F">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">RECFM_F</code><a class="headerlink" href="#cobol.RECFM_F" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple fixed-length records. No header words.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RECFM_F</span><span class="p">(</span><span class="n">RECFM_Parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse RECFM=F; the lrecl is the length of each record.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">lrecl</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param source: the file</span>
<span class="sd">        :param lrecl: the record length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrecl</span><span class="o">=</span> <span class="n">lrecl</span>
    <span class="k">def</span> <span class="nf">record_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="n">data</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrecl</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">data</span>
            <span class="n">data</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrecl</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rdw_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield rows with RDW, effectively RECFM_V format.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_iter</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span> <span class="s2">&quot;&gt;H2x&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span> <span class="p">)</span><span class="o">+</span><span class="n">row</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.RECFM_FB">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">RECFM_FB</code><a class="headerlink" href="#cobol.RECFM_FB" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple fixed-blocked records. No header words.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RECFM_FB</span><span class="p">(</span> <span class="n">RECFM_F</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse RECFM=FB; the lrecl is the length of each record.</span>

<span class="sd">    It&#39;s not clear that there&#39;s any difference between F and FB.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.RECFM_V">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">RECFM_V</code><a class="headerlink" href="#cobol.RECFM_V" title="Permalink to this definition">¶</a></dt>
<dd><p>Variable-length records. Each record has an RDW header word with the length.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RECFM_V</span><span class="p">(</span><span class="n">RECFM_Parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse RECFM=V; the lrecl is a maximum, which we ignore.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">lrecl</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param source: the file</span>
<span class="sd">        :param lrecl: a maximum, but it&#39;s ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">=</span> <span class="n">source</span>
    <span class="k">def</span> <span class="nf">record_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over records, stripped of RDW&#39;s.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rdw</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_iter</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">row</span>
    <span class="k">def</span> <span class="nf">rdw_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over records which include the 4-byte RDW.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rdw</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_iter</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">rdw</span><span class="o">+</span><span class="n">row</span>
    <span class="k">def</span> <span class="nf">_data_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="n">rdw</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">rdw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span> <span class="s2">&quot;&gt;H2x&quot;</span><span class="p">,</span> <span class="n">rdw</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">size</span><span class="o">-</span><span class="mi">4</span> <span class="p">)</span>
            <span class="k">yield</span> <span class="n">rdw</span><span class="p">,</span> <span class="n">data</span>
            <span class="n">rdw</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>We might want to implement the <code class="xref py py-meth docutils literal notranslate"><span class="pre">RECFM_Parser.used()</span></code> method to compare the number of bytes
used against the RDW size.</p>
<dl class="class">
<dt id="cobol.RECFM_VB">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">RECFM_VB</code><a class="headerlink" href="#cobol.RECFM_VB" title="Permalink to this definition">¶</a></dt>
<dd><p>Variable-length, blocked records. Each block has a BDW; each record has an RDW header word.
These BDW and RDW describe the structure of the file.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RECFM_VB</span><span class="p">(</span><span class="n">RECFM_Parser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse RECFM=VB; the lrecl is a maximum, which we ignore.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">lrecl</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param source: the file</span>
<span class="sd">        :param lrecl: a maximum, but it&#39;s ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">=</span> <span class="n">source</span>
    <span class="k">def</span> <span class="nf">record_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over records, stripped of RDW&#39;s.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rdw</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_iter</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">row</span>
    <span class="k">def</span> <span class="nf">rdw_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over records which include the 4-byte RDW.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rdw</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_iter</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">rdw</span><span class="o">+</span><span class="n">row</span>
    <span class="k">def</span> <span class="nf">bdw_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over blocks, which include 4-byte BDW and records with 4-byte RDW&#39;s.&quot;&quot;&quot;</span>
        <span class="n">bdw</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bdw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blksize</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span> <span class="s2">&quot;&gt;H2x&quot;</span><span class="p">,</span> <span class="n">bdw</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">block_data</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">blksize</span><span class="o">-</span><span class="mi">4</span> <span class="p">)</span>
            <span class="k">yield</span> <span class="n">bdw</span><span class="o">+</span><span class="n">block_data</span>
            <span class="n">bdw</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_data_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="n">bdw</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bdw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blksize</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span> <span class="s2">&quot;&gt;H2x&quot;</span><span class="p">,</span> <span class="n">bdw</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">block_data</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">blksize</span><span class="o">-</span><span class="mi">4</span> <span class="p">)</span>
            <span class="n">offset</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">offset</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_data</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_data</span><span class="p">),</span> <span class="s2">&quot;Corrupted Data Block </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block_data</span><span class="p">)</span>
                <span class="n">rdw</span><span class="o">=</span> <span class="n">block_data</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">size</span><span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span> <span class="s2">&quot;&gt;H2x&quot;</span><span class="p">,</span> <span class="n">rdw</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">yield</span> <span class="n">rdw</span><span class="p">,</span> <span class="n">block_data</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="n">size</span><span class="p">]</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">size</span>
            <span class="n">bdw</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>We might want to implement a generic <code class="xref py py-meth docutils literal notranslate"><span class="pre">RECFM_Parser.used()</span></code> method to compare the number of bytes
used against the RDW size and raise an exception in the event of a mismatch.</p>
<dl class="class">
<dt id="cobol.RECFM_N">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">RECFM_N</code><a class="headerlink" href="#cobol.RECFM_N" title="Permalink to this definition">¶</a></dt>
<dd><p>Variable-length records without RDW’s. Exasperating because we have to feed
bytes to the buffer as needed until the record is complete.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RECFM_N</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Parse RECFM=V without RDW (or RECFM=VB without BDW or RDW).</span>
<span class="sd">    The lrecl is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">lrecl</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param source: the file</span>
<span class="sd">        :param lrecl: a maximum, but it&#39;s ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="mi">32768</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">record_iter</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span>
            <span class="c1"># What if used() is not called? This will loop forever!</span>
    <span class="k">def</span> <span class="nf">used</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span> <span class="p">):</span>
        <span class="c1">#print( &quot;Consumed {0} Bytes&quot;.format(bytes) )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">:]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">32768</span><span class="o">-</span><span class="nb">bytes</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.EBCDIC_File">
<em class="property">class </em><code class="descclassname">cobol.</code><code class="descname">EBCDIC_File</code><a class="headerlink" href="#cobol.EBCDIC_File" title="Permalink to this definition">¶</a></dt>
<dd><p>This subclass handles EBCDIC conversion and COMP-3
packed decimal numbers.  For this to work, the schema needs to use slightly different Cell-type conversions.</p>
<p>Otherwise, this is similar to processing simple character data.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EBCDIC_File</span><span class="p">(</span> <span class="n">Character_File</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL &quot;workbook&quot; file with decoding functions for</span>
<span class="sd">    EBCDIC data. If a file_object is provided, it must be</span>
<span class="sd">    opened in byte mode, and no decoder can be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decoder</span><span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getdecoder</span><span class="p">(</span><span class="s1">&#39;cp037&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">file_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">RECFM</span><span class="o">=</span><span class="s2">&quot;N&quot;</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare the workbook for reading.</span>
<span class="sd">        :param name: File name</span>
<span class="sd">        :param file_object: Optional file-like object.  If omitted, the named file is opened.</span>
<span class="sd">            The object must be opened in byte mode; no decoder should be used.</span>
<span class="sd">        :param schema: The schema to use.</span>
<span class="sd">        :param RECFM: The legacy Z/OS RECFM to use. This must be one</span>
<span class="sd">            of &quot;F&quot;, &quot;FB&quot;, &quot;V&quot;, &quot;VB&quot;. This is translated to an appropriate</span>
<span class="sd">            RECFM class: RECFM_F, RECFM_FB, RECFM_V, or RECFM_VB.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="n">file_object</span><span class="p">,</span> <span class="n">schema</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_obj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">the_file</span><span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wb</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">the_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wb</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">=</span> <span class="n">schema</span>
        <span class="n">parser_class</span><span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;F&quot;</span> <span class="p">:</span> <span class="n">RECFM_F</span><span class="p">,</span>
            <span class="s2">&quot;FB&quot;</span><span class="p">:</span> <span class="n">RECFM_FB</span><span class="p">,</span>
            <span class="s2">&quot;V&quot;</span> <span class="p">:</span> <span class="n">RECFM_V</span><span class="p">,</span>
            <span class="s2">&quot;VB&quot;</span><span class="p">:</span> <span class="n">RECFM_VB</span><span class="p">,</span>
            <span class="s2">&quot;N&quot;</span><span class="p">:</span>  <span class="n">RECFM_N</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">RECFM</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">=</span> <span class="n">parser_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wb</span><span class="p">,</span> <span class="n">schema</span><span class="o">.</span><span class="n">lrecl</span><span class="p">())</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.EBCDIC_File.rows_of">
<code class="descclassname">EBCDIC_File.</code><code class="descname">rows_of</code><span class="sig-paren">(</span><em>sheet</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.EBCDIC_File.rows_of" title="Permalink to this definition">¶</a></dt>
<dd><p>We must extend the <code class="xref py py-meth docutils literal notranslate"><span class="pre">workbook.Character_File.rows_of()</span></code> method to deal with
two issues:</p>
<ul>
<li><p class="first">If the schema depends on a variably located DDE, then we need to do the
<a class="reference internal" href="cobol_defs.html#cobol.defs.setSizeAndOffset" title="cobol.defs.setSizeAndOffset"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.setSizeAndOffset()</span></code></a> function using the DDE.
This is done automagically by the <a class="reference internal" href="#cobol.ODO_LazyRow" title="cobol.ODO_LazyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.ODO_LazyRow</span></code></a> object.</p>
</li>
<li><p class="first">The legacy Z/OS RECFM details.</p>
<ul class="simple">
<li>We might have F or FB files, which are simply
long runs of EBCDIC bytes with no line breaks.
The LRECL must match the DDE.</li>
<li>We might have V (or VB) which have 4-byte header on each row (plus a 4-byte header on each block.)
The LRECL doesn’t matter.</li>
<li>We can tolerate the awful situation where it’s variable length (Occurs Depending On)
but there are no RECFM=V or RECFM=VB header words. We call this RECFM=N.
We fetch an oversized buffer and push back bytes beyond the end of the record.</li>
</ul>
<p>This means that the <code class="docutils literal notranslate"><span class="pre">super().rows_of(</span> <span class="pre">sheet</span> <span class="pre">)</span></code> has been replaced with a RECFM-aware
byte-parser. This byte parser may involve a back-and-forth to handle RECFM=N.
In the case of RECFM=N, we provide an overly-large buffer (32768 bytes) and after
any size and offset calculations, the <code class="docutils literal notranslate"><span class="pre">row._size</span></code> shows how many bytes were
actually used.</p>
</li>
</ul>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rows_of</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">sheet</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Iterate through all &quot;rows&quot; of this &quot;sheet&quot;.</span>
<span class="sd">    Really, this means all records of this COBOL file.</span>

<span class="sd">    Note the handshake with RECFM parser to show how many</span>
<span class="sd">    bytes were really needed.  For RECFM_N, this is important.</span>
<span class="sd">    For other RECFM, this is ignored.</span>

<span class="sd">    :py:class:`cobol.ODO_LazyRow` may adjust the schema</span>
<span class="sd">    if it has an Occurs Depending On.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">record_iter</span><span class="p">():</span>
        <span class="n">row</span><span class="o">=</span> <span class="n">ODO_LazyRow</span><span class="p">(</span> <span class="n">sheet</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">used</span><span class="p">(</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">lrecl</span><span class="p">())</span>
        <span class="k">yield</span> <span class="n">row</span>
</pre></div>
</div>
<p>The following functions are used to do data conversions for COBOL EBCDIC files.
Text requires using a codec to translate EBCDIC-encoded characters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">text</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract a text field&#39;s value.&quot;&quot;&quot;</span>
    <span class="n">text</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">EBCDIC_File</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">text</span>
</pre></div>
</div>
<p>When a number usage is <code class="docutils literal notranslate"><span class="pre">DISPLAY</span></code>, it’s text:
we simply convert the bytes from EBCDIC to Unicode
and treat them more-or-less like a text field.</p>
<p>Note the subtlety around “Signed” display fields. The last byte
will include a sign in addition to the digit.</p>
<ul class="simple">
<li>The last EBCDIC character might be ‘xF1’ to ‘xF9’ which is unsigned.</li>
<li>The last EBCDIC character might be ‘xC1’ to ‘xC9’ which is positive.</li>
<li>The last EBCDIC character might be ‘xD1’ to ‘xD9’ which is negative.</li>
</ul>
<p>Really.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">number_display</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract a numeric field&#39;s value.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">size_scale_precision</span><span class="o">.</span><span class="n">signed</span><span class="p">:</span>
        <span class="c1"># Fiddle bits to make EBCDIC char from signed digit.</span>
        <span class="n">last_digit</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span> <span class="p">[(</span><span class="n">buffer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xF0</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span> <span class="k">if</span> <span class="n">buffer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="o">==</span> <span class="mh">0xD</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">text</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">EBCDIC_File</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">last_digit</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">buffer</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">last_digit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Character_File</span><span class="o">.</span><span class="n">number_display</span><span class="p">(</span> <span class="n">sign</span><span class="o">+</span><span class="n">text</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">text</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">EBCDIC_File</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Character_File</span><span class="o">.</span><span class="n">number_display</span><span class="p">(</span> <span class="n">text</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ascii-file">
<h3>10.2.1.5.4. ASCII File<a class="headerlink" href="#ascii-file" title="Permalink to this headline">¶</a></h3>
<p>We could define a subclass for files encoded in ASCII which contain COMP and COMP-3 values.</p>
<p>This is left as a future extension.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Stingray_belon1553_small.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="index.html">The Stingray Schema-Based File Reader, stingray</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">2. Design Considerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="package.html">3. The <code class="docutils literal notranslate"><span class="pre">stingray</span></code> Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="cell.html">4. Cell Module – Data Element Containers and Conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="sheet.html">5. Sheet Module – Sheet and Row Access</a></li>
<li class="toctree-l1"><a class="reference internal" href="schema.html">6. Schema Package – Schema and Attribute Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="schema_loader.html">7. Schema Loader Module – Load Embedded or External Schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="workbook/index.html">8. Workbook Package – Uniform Wrappers for Workbooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="iwork13.html">9. The “Other” Modules: snappy and protobuf</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="cobol.html">10. The COBOL Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer.html">11. The <strong>Stingray</strong> Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="demo/index.html">12. <strong>Stingray</strong> Demo Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">13. History</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing/index.html">14. Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">15. Stingray Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">16. Installation via <code class="docutils literal notranslate"><span class="pre">setup.py</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">17. Licensing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="cobol.html">10. The COBOL Package</a><ul>
      <li>Previous: <a href="cobol.html" title="previous chapter">10. The COBOL Package</a></li>
      <li>Next: <a href="cobol_loader.html" title="next chapter">10.2.2. COBOL Loader Module – Parse COBOL Source to Load a Schema</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2013, S. Lott.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/cobol_init.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>