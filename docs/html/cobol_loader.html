
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>10.2.2. COBOL Loader Module – Parse COBOL Source to Load a Schema &#8212; The Stingray Schema-Based File Reader</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10.2.3. COBOL Definitions Module – Handle COBOL DDE’s" href="cobol_defs.html" />
    <link rel="prev" title="10.2.1. COBOL Package – Extend Schema to Handle EBCDIC" href="cobol_init.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-cobol.loader">
<span id="cobol-loader-module-parse-cobol-source-to-load-a-schema"></span><span id="cobol-loader"></span><h1>10.2.2. COBOL Loader Module – Parse COBOL Source to Load a Schema<a class="headerlink" href="#module-cobol.loader" title="Permalink to this headline">¶</a></h1>
<p>Parsing a spreadsheet schema is relatively easy: see <a class="reference internal" href="schema_loader.html#schema-loader"><span class="std std-ref">Schema Loader Module – Load Embedded or External Schema</span></a>.
Parsing a COBOL schema, however, is a bit more complex. We need to parse
COBOL sources code to decode Data Definition Elements (DDE’s) and create
a usable representation of the DDE that matches the Stingray schema model.</p>
<p>We’ll wind up with two representations of the COBOL schema:</p>
<ul class="simple">
<li>The original DDE hierarchy. See <a class="reference internal" href="#dde-loader-design">DDE Loader Design</a> for details.</li>
<li>A flattened version that’s a  <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Schema</span></code></a> instance.</li>
</ul>
<p>A new <a class="reference internal" href="schema_loader.html#schema.loader.ExternalSchemaLoader" title="schema.loader.ExternalSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.loader.ExternalSchemaLoader</span></code></a> subclass is required
to parse the DDE sublanguage of COBOL.  The <a class="reference internal" href="#cobol-schema-loader-class">COBOL Schema Loader Class</a> section
details this. A loader will build the hierarchical
DDE from the COBOL source, decorate this with size and offset information,
then flatten it into a simple <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Schema</span></code></a> instance.</p>
<div class="section" id="load-a-schema-use-case">
<h2>10.2.2.1. Load A Schema Use Case<a class="headerlink" href="#load-a-schema-use-case" title="Permalink to this headline">¶</a></h2>
<p>The goal of use case is to load a schema encoded in COBOL.  This breaks down
into two steps.</p>
<ol class="arabic simple">
<li>Parse the COBOL “copybook” source file.</li>
<li>Produce a <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><code class="xref py py-mod docutils literal notranslate"><span class="pre">schema.Schema</span></code></a> instance that can be used to access data
in a COBOL file.</li>
</ol>
<p>Ideally, this will look something like the following.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;sample/zipcty.cob&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cobol</span><span class="p">:</span>
    <span class="n">schema</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">COBOLSchemaLoader</span><span class="p">(</span> <span class="n">cobol</span> <span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="c1">#pprint.pprint( schema )</span>
<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="s1">&#39;sample/zipcty1&#39;</span><span class="p">,</span> <span class="s1">&#39;sample/zipcty2&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">Character_File</span><span class="p">(</span> <span class="n">filename</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span> <span class="p">)</span> <span class="k">as</span> <span class="n">wb</span><span class="p">:</span>
        <span class="n">sheet</span><span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="n">sheet</span><span class="p">(</span> <span class="n">filename</span> <span class="p">)</span>
        <span class="n">counts</span><span class="o">=</span> <span class="n">process_sheet</span><span class="p">(</span> <span class="n">sheet</span> <span class="p">)</span>
        <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span> <span class="n">counts</span> <span class="p">)</span>
</pre></div>
</div>
<p>Step 1 is to open the COBOL DDE “copybook” file, <code class="file docutils literal notranslate"><span class="pre">zipcty.cob</span></code> that defines the layout.
We build the schema using a <a class="reference internal" href="#cobol.loader.COBOLSchemaLoader" title="cobol.loader.COBOLSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.COBOLSchemaLoader</span></code></a>.</p>
<p>Step 2 is to open the source data, <code class="file docutils literal notranslate"><span class="pre">zipcty1</span></code> with the data.
We’ve made a <a class="reference internal" href="sheet.html#sheet.Sheet" title="sheet.Sheet"><code class="xref py py-class docutils literal notranslate"><span class="pre">sheet.Sheet</span></code></a> from the file: the sheet’s name is <code class="docutils literal notranslate"><span class="pre">&quot;zipcty1&quot;</span></code>,
the the schema is the external provided when we opened the <a class="reference internal" href="cobol_init.html#cobol.Character_File" title="cobol.Character_File"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.Character_File</span></code></a>.</p>
<p>Once the sheet is available, we can then run some function, <code class="docutils literal notranslate"><span class="pre">process_sheet</span></code>, on the
sheet. This will use the <a class="reference internal" href="sheet.html#sheet.Sheet" title="sheet.Sheet"><code class="xref py py-class docutils literal notranslate"><span class="pre">sheet.Sheet</span></code></a> API to process rows and cells of the
sheet. Each piece of source data is loaded as a kind of <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><code class="xref py py-class docutils literal notranslate"><span class="pre">cell.Cell</span></code></a>.</p>
<p>We can then use appropriate conversions to recover Python objects.
This leads us to the second use case.</p>
<p>Here’s what a <code class="docutils literal notranslate"><span class="pre">process_sheet()</span></code> function might look like in this context.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_sheet</span><span class="p">(</span> <span class="n">sheet</span> <span class="p">):</span>
    <span class="n">schema_dict</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">sheet</span><span class="o">.</span><span class="n">schema</span> <span class="p">)</span>
    <span class="n">schema_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">sheet</span><span class="o">.</span><span class="n">schema</span> <span class="p">)</span> <span class="p">)</span>

    <span class="n">counts</span><span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;read&#39;</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>

    <span class="n">row_iter</span><span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span>
    <span class="n">header</span><span class="o">=</span> <span class="n">header_builder</span><span class="p">(</span> <span class="nb">next</span><span class="p">(</span><span class="n">row_iter</span><span class="p">),</span> <span class="n">schema_dict</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span> <span class="n">header</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">row_iter</span><span class="p">:</span>
        <span class="n">detail</span><span class="o">=</span> <span class="n">row_builder</span><span class="p">(</span> <span class="n">row</span><span class="p">,</span> <span class="n">schema_dict</span> <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span> <span class="n">detail</span> <span class="p">)</span>
        <span class="n">counts</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts</span>
</pre></div>
</div>
<p>First, we’ve build two versions of the schema, indexed by low-level item name
and the full path to an item. In some cases, the low-level DDE items are unique,
and the paths are not required. In other cases, the paths are required.</p>
<p>We’ve initialized some record counts, always a good practice.</p>
<p>We’ve fetched the first record and used some function named <code class="docutils literal notranslate"><span class="pre">header_builder()</span></code> to
transform the record into a header, which we print.</p>
<p>We’ve fetched all other records and used a function named <code class="docutils literal notranslate"><span class="pre">row_builder()</span></code> to
transform every following record into details, which we also print.</p>
<p>This shows a physical head-tail processing. In some cases, there’s an attribute
which differentiates headers, body and trailers.</p>
</div>
<div class="section" id="use-a-schema-use-case">
<h2>10.2.2.2. Use A Schema Use Case<a class="headerlink" href="#use-a-schema-use-case" title="Permalink to this headline">¶</a></h2>
<p>The goal of this use case is to build usable Python objects from the source file data.</p>
<p>For each row, there’s a two-step operation.</p>
<ol class="arabic simple">
<li>Access elements of each row using the COBOL DDE structure.</li>
<li>Build Python objects from the Cells found in the row.</li>
</ol>
<p>Generally, we must use lazy evaluation as shown in this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">header_builder</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">file_version_year</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;FILE-VERSION-YEAR&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">file_version_month</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;FILE-VERSION-MONTH&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">copyright_symbol</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;COPYRIGHT-SYMBOL&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">tape_sequence_no</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;TAPE-SEQUENCE-NO&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">row_builder</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">zip_code</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;ZIP-CODE&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">update_key_no</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;UPDATE-KEY-NO&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">low_sector</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;COUNTY-CROSS-REFERENCE-RECORD.ZIP-ADD-ON-RANGE.ZIP-ADD-ON-LOW-NO.ZIP-SECTOR-NO&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">low_segment</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;COUNTY-CROSS-REFERENCE-RECORD.ZIP-ADD-ON-RANGE.ZIP-ADD-ON-LOW-NO.ZIP-SEGMENT-NO&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">high_sector</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;COUNTY-CROSS-REFERENCE-RECORD.ZIP-ADD-ON-RANGE.ZIP-ADD-ON-HIGH-NO.ZIP-SECTOR-NO&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">high_segment</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;COUNTY-CROSS-REFERENCE-RECORD.ZIP-ADD-ON-RANGE.ZIP-ADD-ON-HIGH-NO.ZIP-SEGMENT-NO&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">state_abbrev</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;STATE-ABBREV&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">county_no</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;COUNTY-NO&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
        <span class="n">county_name</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="s1">&#39;COUNTY-NAME&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">to_str</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Each cell is accessed in a three-step operation.</p>
<ol class="arabic simple">
<li>Get the schema information via <code class="docutils literal notranslate"><span class="pre">schema['shortname']</span></code> or <code class="docutils literal notranslate"><span class="pre">schema['full.path.name']</span></code></li>
<li>Build the <code class="docutils literal notranslate"><span class="pre">Cell</span></code> using the schema information via <code class="docutils literal notranslate"><span class="pre">row.cell(...)</span></code>.</li>
<li>Convert the <code class="docutils literal notranslate"><span class="pre">Cell</span></code> to our target type via <code class="docutils literal notranslate"><span class="pre">...to_str()</span></code>.</li>
</ol>
<p>We <strong>must</strong> do this in steps because the COBOL records may have invalid fields,
or <code class="docutils literal notranslate"><span class="pre">REDEFINES</span></code> or <code class="docutils literal notranslate"><span class="pre">OCCURS</span> <span class="pre">DEPENDING</span> <span class="pre">ON</span></code> clauses.</p>
<p>If we want to build higher-level, pure Python objects associated with some
application, we’ll do this.</p>
<pre class="literal-block">
def build_object(row, schema):
    return Object( **row_builder(row, schema) )
</pre>
<p>We’ll simply assure that the row’s dictionary keys are the proper keyword arguments for
our application class definitions.</p>
<p>When we have indexing to do, this is only slightly more complex. The resulting object
will be a list-of-list structure, and we apply the indexes in the order from the original
DDE definition to pick apart the lists.</p>
</div>
<div class="section" id="extensions-and-special-cases">
<h2>10.2.2.3. Extensions and Special Cases<a class="headerlink" href="#extensions-and-special-cases" title="Permalink to this headline">¶</a></h2>
<p>The typical use cases is something like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;sample/zipcty.cob&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cobol</span><span class="p">:</span>
    <span class="n">schema</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">COBOLSchemaLoader</span><span class="p">(</span> <span class="n">cobol</span> <span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
<span class="k">with</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">Character_File</span><span class="p">(</span> <span class="n">filename</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span> <span class="p">)</span> <span class="k">as</span> <span class="n">wb</span><span class="p">:</span>
    <span class="n">sheet</span><span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="n">sheet</span><span class="p">(</span> <span class="n">filename</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">sheet</span><span class="o">.</span><span class="n">rows</span><span class="p">():</span>
        <span class="n">dump</span><span class="p">(</span> <span class="n">schema</span><span class="p">,</span> <span class="n">row</span> <span class="p">)</span>
</pre></div>
</div>
<p>This will use the default parsing to create a schema from a DDA and process a
file, dumping each record.</p>
<p>There are two common extension:</p>
<ul class="simple">
<li>new lexical scanner, and</li>
<li>different ODO handling.</li>
</ul>
<p>To change lexical scanners, we create a new subclass of the parser.</p>
<p>We use this by subclassing <code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.COBOLSchemaLoader</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySchemaLoader</span><span class="p">(</span> <span class="n">cobol</span><span class="o">.</span><span class="n">COBOLSchemaLoader</span> <span class="p">):</span>
    <span class="n">lexer_class</span><span class="o">=</span> <span class="n">cobol</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">Lexer_Long_Lines</span>
</pre></div>
</div>
<p>This will use a different lexical scanner when parsing a DDE file.</p>
<p>We may also need to change the record factory. This involves two separate extensions.
We must extend the <a class="reference internal" href="#cobol.loader.RecordFactory" title="cobol.loader.RecordFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.RecordFactory</span></code></a> to change the features.
Then we can extend <a class="reference internal" href="#cobol.loader.COBOLSchemaLoader" title="cobol.loader.COBOLSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.COBOLSchemaLoader</span></code></a> to use this record
factory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExtendedRecordFactory</span><span class="p">(</span> <span class="n">cobol</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">RecordFactory</span> <span class="p">):</span>
    <span class="n">occurs_dependingon_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">OccursDependingOnLimit</span>
    <span class="c1">#Default is occurs_dependingon_class= stingray.cobol.defs.OccursDependingOn</span>

<span class="k">class</span> <span class="nc">MySchemaLoader</span><span class="p">(</span> <span class="n">cobol</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">COBOLSchemaLoader</span> <span class="p">):</span>
    <span class="n">record_factory_class</span><span class="o">=</span> <span class="n">ExtendedRecordFactory</span>
</pre></div>
</div>
<p>This will use a different record factory to elaborate the details of the DDE.</p>
</div>
<div class="section" id="dde-loader-design">
<h2>10.2.2.4. DDE Loader Design<a class="headerlink" href="#dde-loader-design" title="Permalink to this headline">¶</a></h2>
<p>A DDE contains a recursive definition of a COBOL group-level DDE.
There are two basic species of COBOL DDE’s: elemetary items, which have a <code class="docutils literal notranslate"><span class="pre">PICTURE</span></code> clause,
and group-level items, which contain lower-level items.  There are several optional
features of every DDE, including an <code class="docutils literal notranslate"><span class="pre">OCCURS</span></code> clause and a <code class="docutils literal notranslate"><span class="pre">REDEFINES</span></code> clause.
In addition to the required picture clause, elementary items have an optional <code class="docutils literal notranslate"><span class="pre">USAGE</span></code> clause,
and optional <code class="docutils literal notranslate"><span class="pre">SIGN</span></code> clause.</p>
<p>A single class, <a class="reference internal" href="cobol_defs.html#cobol.defs.DDE" title="cobol.defs.DDE"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.DDE</span></code></a>, defines the features of a group-level item.  It supports
the occurs and redefines features.  It can contain a number of DDE items.
The leaves of the tree define the features of an elementary item.</p>
<p>See <a class="reference internal" href="cobol_defs.html#cobol-defs"><span class="std std-ref">COBOL Definitions Module – Handle COBOL DDE’s</span></a> for details.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PICTURE</span></code> clause specifies how to interpret a sequence of bytes.  The picture
clause interacts with the optional <code class="docutils literal notranslate"><span class="pre">USAGE</span></code> clause, <code class="docutils literal notranslate"><span class="pre">SIGN</span></code> clause and <code class="docutils literal notranslate"><span class="pre">SYNCHRONIZED</span></code> clause
to fully define the encoding.  The picture clause uses a complex format of code characters
to define either individual character bytes (when the usage is display) or pairs of decimal digit bytes
(when the usage is <code class="docutils literal notranslate"><span class="pre">COMP-3</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">OCCURS</span></code> clause specifies an array of elements.  If the occurs clause appears
on a group level item, the sub-record is repeated.  If the occurs clause appears
on an elementary item, that item is repeated.</p>
<p>An <strong>occurs depending on</strong> (ODO) makes the positions of each field dependent on actual
data present in the record. This is a rare, but necessary complication.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">REDEFINES</span></code> clause defines an alias for input bytes.  When some field <em>R</em> redefines
a previously defined field <em>F</em>, the storage bytes are used for both <em>R</em> and <em>F</em>.
The record structure itself does not provide a way to disambiguate the interpretation of the bytes.
Program logic must be examined to determine the conditions under which each interpretation is valid.
It’s entirely possible either interpretation has invalid fields.</p>
<div class="section" id="dde-post-processing">
<h3>10.2.2.4.1. DDE Post-processing<a class="headerlink" href="#dde-post-processing" title="Permalink to this headline">¶</a></h3>
<p>We have a number of functions to traverse a DDE structure to write
reports on the structure. The DDE has an <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code> method which
provides a complete pre-order depth-first traversal of the record
structure.</p>
<p>Here are some functions which traverse the entire DDE structure.</p>
<ul class="simple">
<li><a class="reference internal" href="cobol_defs.html#cobol.defs.report" title="cobol.defs.report"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.report()</span></code></a> reports on the DDE structure.</li>
<li><a class="reference internal" href="cobol_defs.html#cobol.defs.source" title="cobol.defs.source"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.source()</span></code></a> shows canonical source.</li>
<li><a class="reference internal" href="cobol_defs.html#cobol.defs.search" title="cobol.defs.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.search()</span></code></a> locates a name in DDE structure.</li>
<li><a class="reference internal" href="cobol_defs.html#cobol.defs.resolver" title="cobol.defs.resolver"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.resolver()</span></code></a> does name resolution throughout the DDE structure.</li>
<li><a class="reference internal" href="cobol_defs.html#cobol.defs.setDimensionality" title="cobol.defs.setDimensionality"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.setDimensionality()</span></code></a> walks up the hierarchy from each node to compute
the net occurrences based on all parent OCCURS clauses.</li>
</ul>
<p>Once there is data available, we have these additional functions.</p>
<ul class="simple">
<li><a class="reference internal" href="cobol_defs.html#cobol.defs.setSizeAndOffset" title="cobol.defs.setSizeAndOffset"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.setSizeAndOffset()</span></code></a> computes the offset and size of each element.</li>
<li><a class="reference internal" href="cobol_init.html#cobol.dump" title="cobol.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.dump()</span></code></a> dumps a record showing the original DDE and the values.</li>
</ul>
<p>Note that <a class="reference internal" href="cobol_defs.html#cobol.defs.setSizeAndOffset" title="cobol.defs.setSizeAndOffset"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.setSizeAndOffset()</span></code></a> is recursive, not iterative.
It needs to manage subtotals based on ascent and descent in the hierarchy.</p>
</div>
<div class="section" id="dde-parser">
<h3>10.2.2.4.2. DDE Parser<a class="headerlink" href="#dde-parser" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="#cobol.loader.RecordFactory" title="cobol.loader.RecordFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.RecordFactory</span></code></a> object reads a file of text and either creates a
DDE or raises an exception. If the text is a valid COBOL record
definition, a DDE is created.  If there are syntax errors, an exception
is raised.</p>
<p>The <a class="reference internal" href="#cobol.loader.RecordFactory" title="cobol.loader.RecordFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.RecordFactory</span></code></a> depends on a <a class="reference internal" href="#cobol.loader.Lexer" title="cobol.loader.Lexer"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.Lexer</span></code></a>
instance to do lexical scanning of
COBOL source. The lexical scanner can be subclassed to pre-process COBOL
source.  This is necessary because of the variety of source formats that
are permitted.  Shop standards may include or exclude features like
program identification, line numbers, format control and other
decoration of the input.</p>
<p>The <a class="reference internal" href="#cobol.loader.RecordFactory.makeRecord" title="cobol.loader.RecordFactory.makeRecord"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cobol.loader.RecordFactory.makeRecord()</span></code></a> method
does the parsing of
the record definition. Each individual DDE statement is parsed.  The
level number information is used to define the correct grouping of
elements.  When the structure(s) is parsed, it is decorated with size and
offset information for each element.</p>
<p>Note that multiple 01 levels are possible in a single COBOL copybook.
This is confusing and potentially complicated, but it occurs IRL.</p>
</div>
<div class="section" id="field-values">
<h3>10.2.2.4.3. Field Values<a class="headerlink" href="#field-values" title="Permalink to this headline">¶</a></h3>
<p>The COBOL language, and IBM’s extensions,
provide for a number of usage options.  In this application, three basic types
of usage strategies are supported:</p>
<ul class="simple">
<li><strong>DISPLAY</strong>.  These are bytes, one per character, described by the picture clause.
They can be EBCDIC or ASCII.  We use the <code class="docutils literal notranslate"><span class="pre">codecs</span></code> module to
convert EBCDIC characters to Unicode for further processing.</li>
<li><strong>COMP</strong>.  These are binary fields of 2, 4 or 8 bytes, with the size implied by the picture clause.</li>
<li><strong>COMP-3</strong>.  These are packed decimal fields, with the size derived from the picture clause;
there are two digits packed into each byte, with an extra half-byte for a sign.</li>
</ul>
<p>These require different strategies for decoding the input bytes.</p>
<p>Additional types include COMP-1 and COMP-2 which are single- and double-precision floating-point.
They’re rare enough that we ignore them.</p>
</div>
<div class="section" id="occurs-depending-on">
<h3>10.2.2.4.4. Occurs Depending On<a class="headerlink" href="#occurs-depending-on" title="Permalink to this headline">¶</a></h3>
<p>Support for Occurs Depending On is based several features of COBOL.</p>
<p>The syntax for ODO is more complex: <code class="docutils literal notranslate"><span class="pre">OCCURS</span> <span class="pre">[int</span> <span class="pre">TO]</span> <span class="pre">int</span> <span class="pre">[TIMES]</span> <span class="pre">DEPENDING</span> <span class="pre">[ON]</span> <span class="pre">name</span></code>.
Compare this with simple <code class="docutils literal notranslate"><span class="pre">OCCURS</span> <span class="pre">int</span> <span class="pre">[TIMES]</span></code>.</p>
<p>This leads to variable byte positions for data items which follow the occurs clause,
based on the <em>name</em> value.</p>
<p>This means that the offset is not necessarily fixed when there’s a complex ODO.
We’ll have to make offset (and size) a property that has one of two strategies.</p>
<ul class="simple">
<li>Statically Located. The base case where offsets are static.</li>
<li>Variably Located. The complex ODO situation where there’s an ODO in the record.
<strong>All</strong> ODO “depends on” fields become part of the offset calculation. This means
we need an index for depends on clauses.</li>
</ul>
<p>The technical buzzphrase is “a data item following, but not subordinate to, a variable-length table in the same level-01 record.”</p>
<p>See <a class="reference external" href="http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=%2Fcom.ibm.aix.cbl.doc%2Ftptbl27.htm">http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=%2Fcom.ibm.aix.cbl.doc%2Ftptbl27.htm</a></p>
<p>These are the “Appendix D, Complex ODO” rules.</p>
<p>The design consequences are these.</p>
<ol class="arabic">
<li><p class="first">There are three species of relationships between DDE elements:
Predecessor/Successor, Parent/Child (or Group/Elementary),
and Redefines. Currently, the pred/succ relationship is
implied by the parent having a sequence of children. We can’t easily
find a predecessor without a horrible <span class="math notranslate nohighlight">\(\textbf{O}(n)\)</span> search.</p>
</li>
<li><p class="first">There are two strategies for doing offset/size calculations.</p>
<ul>
<li><p class="first">Statically Located. The <a class="reference internal" href="cobol_defs.html#cobol.defs.setSizeAndOffset" title="cobol.defs.setSizeAndOffset"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.setSizeAndOffset()</span></code></a> function can be used
once, right after the schema is parsed.</p>
</li>
<li><p class="first">Variably Located. The calculation of size and offset is based on live data.
The <a class="reference internal" href="cobol_defs.html#cobol.defs.setSizeAndOffset" title="cobol.defs.setSizeAndOffset"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.setSizeAndOffset()</span></code></a> function must be used after the
row is fetched but before any other processing.</p>
<p>This is done automagically by a <a class="reference internal" href="sheet.html#sheet.LazyRow" title="sheet.LazyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">sheet.LazyRow</span></code></a> object.</p>
</li>
</ul>
</li>
</ol>
<p>The offset calculation can be seen as a recursive trip “up” the tree
following redefines, predecessor and parent relationships (in that order)
to calculate the size of everything prior to the element in question.
We could make offset and total size into properties which do this recursive
calculation.</p>
<p>The “size” of a elementary items is still simply based on the picture.
For group items, however, size becomes based on total size which in
turn, may be based on ODO data.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">88-level items could create boolean-valued properties.</p>
</div>
</div>
<div class="section" id="model">
<h3>10.2.2.4.5. Model<a class="headerlink" href="#model" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>http://yuml.me/diagram/scruffy;/class/
#cobol_loader,
[Schema]&lt;&gt;-[RepeatingAttribute],
[SchemaLoader]-builds-&gt;[Schema],
[SchemaLoader]^[COBOLSchemaLoader],
[COBOLSchemaLoader]-&gt;[Lexer],
[COBOLSchemaLoader]-&gt;[RecordFactory],
[RecordFactory]&lt;&gt;-[DDE].
</pre></div>
</div>
<img alt="_images/cobol_loader.png" src="_images/cobol_loader.png" />
</div>
</div>
<div class="section" id="overheads">
<h2>10.2.2.5. Overheads<a class="headerlink" href="#overheads" title="Permalink to this headline">¶</a></h2>
<p>Ultimately, we’re writing a new <a class="reference internal" href="schema_loader.html#schema.loader.ExternalSchemaLoader" title="schema.loader.ExternalSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.loader.ExternalSchemaLoader</span></code></a>.
The purpose of this is to build a <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Schema</span></code></a> instance
from COBOL source instead of some other source.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;stingray.cobol.loader -- Parse a COBOL DDE and build a usable Schema.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">stingray.schema.loader</span>
<span class="kn">import</span> <span class="nn">stingray.cobol</span>
<span class="kn">import</span> <span class="nn">stingray.cobol.defs</span>
</pre></div>
</div>
<p>A module-level logger.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">logger</span><span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span> <span class="vm">__name__</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="parsing-exceptions">
<h2>10.2.2.6. Parsing Exceptions<a class="headerlink" href="#parsing-exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cobol.loader.SyntaxError">
<em class="property">class </em><code class="descclassname">cobol.loader.</code><code class="descname">SyntaxError</code><a class="headerlink" href="#cobol.loader.SyntaxError" title="Permalink to this definition">¶</a></dt>
<dd><p>These are compilation problems.  We have syntax which
is utterly baffling.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SyntaxError</span><span class="p">(</span> <span class="ne">Exception</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;COBOL syntax error.&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="picture-clause-parsing">
<h2>10.2.2.7. Picture Clause Parsing<a class="headerlink" href="#picture-clause-parsing" title="Permalink to this headline">¶</a></h2>
<p>Picture clause parsing is done as the DDE element is created.  Not for a great
reason.  It’s derived data from the source picture clause.</p>
<p>It could be done in the parser, also.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">9(5)V99</span></code> is common, precision is easily the characters after the “.” or “V”.
However, there can be several ()’d groups of numbers <code class="docutils literal notranslate"><span class="pre">9(5)V9(3)</span></code> kind of of thing.
So precision in the latter case is 3, making things a little more complex.</p>
<p>Also, we don’t handle separate sign very gracefully. It seems little-used, so
we’re comfortable ignoring it.</p>
<dl class="class">
<dt id="cobol.loader.Picture">
<em class="property">class </em><code class="descclassname">cobol.loader.</code><code class="descname">Picture</code><a class="headerlink" href="#cobol.loader.Picture" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the various attribtes of a COBOL PICTURE clause.</p>
<dl class="attribute">
<dt id="cobol.loader.Picture.final">
<code class="descname">final</code><a class="headerlink" href="#cobol.loader.Picture.final" title="Permalink to this definition">¶</a></dt>
<dd><p>the final picture</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.loader.Picture.alpha">
<code class="descname">alpha</code><a class="headerlink" href="#cobol.loader.Picture.alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean; True if any <code class="docutils literal notranslate"><span class="pre">&quot;X&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code>; False if all <code class="docutils literal notranslate"><span class="pre">&quot;9&quot;</span></code> and related</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.loader.Picture.length">
<code class="descname">length</code><a class="headerlink" href="#cobol.loader.Picture.length" title="Permalink to this definition">¶</a></dt>
<dd><p>length of the final picture</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.loader.Picture.scale">
<code class="descname">scale</code><a class="headerlink" href="#cobol.loader.Picture.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>count of <code class="docutils literal notranslate"><span class="pre">&quot;P&quot;</span></code> positions, often zero</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.loader.Picture.precision">
<code class="descname">precision</code><a class="headerlink" href="#cobol.loader.Picture.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>digits to the right of the decimal point</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.loader.Picture.signed">
<code class="descname">signed</code><a class="headerlink" href="#cobol.loader.Picture.signed" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean; True if any <code class="docutils literal notranslate"><span class="pre">&quot;S&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;-&quot;</span></code> or related</p>
</dd></dl>

<dl class="attribute">
<dt id="cobol.loader.Picture.decimal">
<code class="descname">decimal</code><a class="headerlink" href="#cobol.loader.Picture.decimal" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;V&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Picture</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span> <span class="s1">&#39;Picture&#39;</span><span class="p">,</span>
    <span class="s1">&#39;final, alpha, length, scale, precision, signed, decimal&#39;</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="cobol.loader.picture_parser">
<code class="descclassname">cobol.loader.</code><code class="descname">picture_parser</code><span class="sig-paren">(</span><em>pic</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.picture_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the text of a PICTURE definition.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">picture_parser</span><span class="p">(</span> <span class="n">pic</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rewrite a picture clause to eliminate ()&#39;s, S&#39;s, V&#39;s, P&#39;s, etc.</span>
<span class="sd">    :param pic: Sounce text.</span>
<span class="sd">    :returns: Picture instance: final, alpha, len(final), scale,</span>
<span class="sd">        precision, signed, decimal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span><span class="o">=</span> <span class="p">[]</span>
    <span class="n">scale</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="n">decimal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">char_iter</span><span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">pic</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">char_iter</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="s1">&#39;9&#39;</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;*&#39;</span><span class="p">,</span><span class="s1">&#39;$&#39;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">decimal</span><span class="p">:</span> <span class="n">precision</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span>
            <span class="n">nc</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">char_iter</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">nc</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;picture error in </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pic</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s2">&quot;DB&quot;</span> <span class="p">)</span>
            <span class="n">signed</span><span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span>  <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="n">nc</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">char_iter</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">nc</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;picture error in </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pic</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s2">&quot;CR&quot;</span> <span class="p">)</span>
            <span class="n">signed</span><span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">irpt</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">char_iter</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span> <span class="k">break</span>
                    <span class="n">irpt</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">irpt</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span> <span class="s2">&quot;picture error in </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pic</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">assert</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">,</span>  <span class="s2">&quot;picture error in </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pic</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">irpt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">decimal</span><span class="p">:</span> <span class="n">precision</span> <span class="o">+=</span> <span class="n">irpt</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
            <span class="c1"># silently drop an &quot;S&quot;.</span>
            <span class="c1"># Note that &#39;S&#39; plus a SIGN SEPARATE option increases the size of the picture!</span>
            <span class="n">signed</span><span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">c</span>  <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
            <span class="c1"># &quot;P&quot; sets scale and isn&#39;t represented.</span>
            <span class="n">scale</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">c</span>  <span class="o">==</span> <span class="s2">&quot;V&quot;</span><span class="p">:</span>
            <span class="c1"># &quot;V&quot; sets precision and isn&#39;t represented.</span>
            <span class="n">decimal</span><span class="o">=</span> <span class="s2">&quot;V&quot;</span>
        <span class="k">elif</span> <span class="n">c</span>  <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
            <span class="n">decimal</span><span class="o">=</span> <span class="s2">&quot;.&quot;</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s2">&quot;.&quot;</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span> <span class="s2">&quot;Picture error in </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pic</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">final</span><span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">out</span> <span class="p">)</span>
    <span class="n">alpha</span><span class="o">=</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">final</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">final</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">final</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span> <span class="s2">&quot;PIC </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> alpha=</span><span class="si">{2}</span><span class="s2"> scale=</span><span class="si">{3}</span><span class="s2"> prec=</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pic</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span> <span class="p">)</span>
    <span class="c1"># Note: Actual bytes consumed depends on len(final) and usage!</span>
    <span class="k">return</span> <span class="n">Picture</span><span class="p">(</span> <span class="n">final</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">final</span><span class="p">),</span> <span class="n">scale</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="n">decimal</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="lexical-scanning">
<h2>10.2.2.8. Lexical Scanning<a class="headerlink" href="#lexical-scanning" title="Permalink to this headline">¶</a></h2>
<p>The lexical scanner can be subclassed to extend its capability.  The default
lexical scanner provides a <a class="reference internal" href="#cobol.loader.Lexer.clean" title="cobol.loader.Lexer.clean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Lexer.clean()</span></code></a> method that simply removes comments.
This may need to be overridden to remove line numbers (from positions 72-80),
module identification (from positions 1-5), and format control directives.</p>
<p>Also, we have to deal with “Compiler Directing Statements”: EJECT, SKIP1, SKIP2 and SKIP3.
These are simply noise that may appear in the source.</p>
<dl class="class">
<dt id="cobol.loader.Lexer">
<em class="property">class </em><code class="descclassname">cobol.loader.</code><code class="descname">Lexer</code><a class="headerlink" href="#cobol.loader.Lexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic lexer that simply removes comments and the first six positions of each line.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Lexer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Lexical scanner for COBOL.  Iterates over tokens in source text.&quot;&quot;&quot;</span>
    <span class="n">separator</span><span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="sa">r</span><span class="s1">&#39;[.,;]?\s&#39;</span> <span class="p">)</span>
    <span class="n">quote1</span><span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="sa">r</span><span class="s2">&quot;&#39;[^&#39;]*&#39;&quot;</span> <span class="p">)</span>
    <span class="n">quote2</span><span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="sa">r</span><span class="s1">&#39;&quot;[^&quot;]*&quot;&#39;</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">replacing</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacing</span><span class="o">=</span> <span class="n">replacing</span> <span class="ow">or</span> <span class="p">[]</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.loader.Lexer.clean">
<code class="descclassname">Lexer.</code><code class="descname">clean</code><span class="sig-paren">(</span><em>line</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.Lexer.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>The default process for cleaning a line. Simply rstrip trailing spaces.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clean</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">line</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default cleaner removes positions 0:6.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">line</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.loader.Lexer.scan">
<code class="descclassname">Lexer.</code><code class="descname">scan</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.Lexer.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate the sequence of tokens in the input stream.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scan</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">text</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Locate the next token in the input stream.</span>
<span class="sd">    - Clean 6-char lead-in plus trailing whitespace</span>
<span class="sd">    - Add one extra space to distinguish end-of-line ``&#39;. &#39;``</span>
<span class="sd">      from picture clause.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
        <span class="n">text</span><span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">all_lines</span><span class="o">=</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">text</span> <span class="p">)</span>
    <span class="c1"># Remove comments, blank lines and compiler directives</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="p">(</span> <span class="n">line</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_lines</span>
            <span class="k">if</span> <span class="n">line</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;EJECT&quot;</span><span class="p">,</span> <span class="s2">&quot;SKIP1&quot;</span><span class="p">,</span> <span class="s2">&quot;SKIP2&quot;</span><span class="p">,</span> <span class="s2">&quot;SKIP3&quot;</span><span class="p">)</span> <span class="p">)</span>
    <span class="c1"># Break remaining lines into words</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span> <span class="n">line</span> <span class="p">)</span>
        <span class="c1"># Apply all replacing rules.</span>
        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacing</span><span class="p">:</span>
            <span class="n">line</span><span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">old</span><span class="p">,</span><span class="n">new</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacing</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span> <span class="s2">&quot;Post-Replacing </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">current</span><span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span>
                <span class="c1"># apostrophe string, break on balancing apostrophe</span>
                <span class="n">match</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote1</span><span class="o">.</span><span class="n">match</span><span class="p">(</span> <span class="n">current</span> <span class="p">)</span>
                <span class="n">space</span><span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
                <span class="c1"># quote string, break on balancing quote</span>
                <span class="n">match</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote2</span><span class="o">.</span><span class="n">match</span><span class="p">(</span> <span class="n">current</span> <span class="p">)</span>
                <span class="n">space</span><span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">match</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">separator</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">current</span> <span class="p">)</span>
                <span class="n">space</span><span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">space</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># starts with separator</span>
                    <span class="n">space</span><span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">token</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">[:</span><span class="n">space</span><span class="p">],</span> <span class="n">current</span><span class="p">[</span><span class="n">space</span><span class="p">:]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span> <span class="n">token</span> <span class="p">)</span>
            <span class="k">yield</span> <span class="n">token</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.loader.Lexer_Long_Lines">
<em class="property">class </em><code class="descclassname">cobol.loader.</code><code class="descname">Lexer_Long_Lines</code><a class="headerlink" href="#cobol.loader.Lexer_Long_Lines" title="Permalink to this definition">¶</a></dt>
<dd><p>More sophisticated lexer that removes the first six positions of each line.
If the line is over 72 positions, it also removes positions [71:80].
Since it’s an extension to <a class="reference internal" href="#cobol.loader.Lexer" title="cobol.loader.Lexer"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.Lexer</span></code></a>, it also removes comments.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Lexer_Long_Lines</span><span class="p">(</span> <span class="n">Lexer</span> <span class="p">):</span>

    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">line</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove positions 72:80 and 0:6.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">72</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">72</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">line</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
</pre></div>
</div>
<p>We use this by subclassing <code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.COBOLSchemaLoader</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySchemaLoader</span><span class="p">(</span> <span class="n">cobol</span><span class="o">.</span><span class="n">COBOLSchemaLoader</span> <span class="p">):</span>
    <span class="n">lexer_class</span><span class="o">=</span> <span class="n">cobol</span><span class="o">.</span><span class="n">Lexer_Long_Lines</span>
</pre></div>
</div>
</div>
<div class="section" id="parsing">
<h2>10.2.2.9. Parsing<a class="headerlink" href="#parsing" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#cobol.loader.RecordFactory" title="cobol.loader.RecordFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.loader.RecordFactory</span></code></a> class is the parser for record definitions.
The parser has three basic sets of methods:</p>
<ol class="arabic simple">
<li>clause parsing methods,</li>
<li>element parsing methods and</li>
<li>complete record layout parsing.</li>
</ol>
<dl class="class">
<dt id="cobol.loader.RecordFactory">
<em class="property">class </em><code class="descclassname">cobol.loader.</code><code class="descname">RecordFactory</code><a class="headerlink" href="#cobol.loader.RecordFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a record layout. This means parsing a sequence of DDE’s and
assembling them into a proper structure.  Each element consists of a sequence of
individual clauses.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RecordFactory</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Parse a copybook, creating a DDE structure.&quot;&quot;&quot;</span>
    <span class="n">noisewords</span><span class="o">=</span> <span class="p">{</span><span class="s2">&quot;WHEN&quot;</span><span class="p">,</span><span class="s2">&quot;IS&quot;</span><span class="p">,</span><span class="s2">&quot;TIMES&quot;</span><span class="p">}</span>
    <span class="n">keywords</span><span class="o">=</span> <span class="p">{</span><span class="s2">&quot;BLANK&quot;</span><span class="p">,</span><span class="s2">&quot;ZERO&quot;</span><span class="p">,</span><span class="s2">&quot;ZEROS&quot;</span><span class="p">,</span><span class="s2">&quot;ZEROES&quot;</span><span class="p">,</span><span class="s2">&quot;SPACES&quot;</span><span class="p">,</span>
        <span class="s2">&quot;DATE&quot;</span><span class="p">,</span><span class="s2">&quot;FORMAT&quot;</span><span class="p">,</span><span class="s2">&quot;EXTERNAL&quot;</span><span class="p">,</span><span class="s2">&quot;GLOBAL&quot;</span><span class="p">,</span>
        <span class="s2">&quot;JUST&quot;</span><span class="p">,</span><span class="s2">&quot;JUSTIFIED&quot;</span><span class="p">,</span><span class="s2">&quot;LEFT&quot;</span><span class="p">,</span><span class="s2">&quot;RIGHT&quot;</span>
        <span class="s2">&quot;OCCURS&quot;</span><span class="p">,</span><span class="s2">&quot;DEPENDING&quot;</span><span class="p">,</span><span class="s2">&quot;ON&quot;</span><span class="p">,</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span>
        <span class="s2">&quot;PIC&quot;</span><span class="p">,</span><span class="s2">&quot;PICTURE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;REDEFINES&quot;</span><span class="p">,</span><span class="s2">&quot;RENAMES&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SIGN&quot;</span><span class="p">,</span><span class="s2">&quot;LEADING&quot;</span><span class="p">,</span><span class="s2">&quot;TRAILING&quot;</span><span class="p">,</span><span class="s2">&quot;SEPARATE&quot;</span><span class="p">,</span><span class="s2">&quot;CHARACTER&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SYNCH&quot;</span><span class="p">,</span><span class="s2">&quot;SYNCHRONIZED&quot;</span><span class="p">,</span>
        <span class="s2">&quot;USAGE&quot;</span><span class="p">,</span><span class="s2">&quot;DISPLAY&quot;</span><span class="p">,</span><span class="s2">&quot;COMP-3&quot;</span><span class="p">,</span>
        <span class="s2">&quot;VALUE&quot;</span><span class="p">,</span><span class="s2">&quot;.&quot;</span><span class="p">}</span>

    <span class="n">redefines_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">Redefines</span>
    <span class="n">successor_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">Successor</span>
    <span class="n">group_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">Group</span>
    <span class="n">parent_usage_class</span> <span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">UsageParent</span>
    <span class="n">display_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">UsageDisplay</span>
    <span class="n">comp_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">UsageComp</span>
    <span class="n">comp3_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">UsageComp3</span>
    <span class="n">occurs_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">Occurs</span>
    <span class="n">occurs_fixed_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">OccursFixed</span>
    <span class="n">occurs_dependingon_class</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">OccursDependingOn</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="p">)</span>
</pre></div>
</div>
<p>Each of these parsing functions has a precondition of the last examined token
in <code class="docutils literal notranslate"><span class="pre">self.token</span></code>.  They have a post-condition of leaving a <strong>not</strong>-examined
token in <code class="docutils literal notranslate"><span class="pre">self.token</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">picture</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse a PICTURE clause.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;IS&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="n">pic</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pic</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">blankWhenZero</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gracefully skip over a BLANK WHEN ZERO clause.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;WHEN&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;ZERO&quot;</span><span class="p">,</span><span class="s2">&quot;ZEROES&quot;</span><span class="p">,</span><span class="s2">&quot;ZEROS&quot;</span><span class="p">}:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">justified</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gracefully skip over a JUSTIFIED clause.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;RIGHT&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">occurs</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse an OCCURS clause.&quot;&quot;&quot;</span>
    <span class="n">occurs</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">occurs</span> <span class="o">==</span> <span class="s2">&quot;TO&quot;</span><span class="p">:</span>
        <span class="c1"># format 2: occurs depending on with assumed 1 for the lower limit</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">occurs2</span><span class="p">(</span> <span class="s1">&#39;&#39;</span> <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;TO&quot;</span><span class="p">:</span>
        <span class="c1"># format 2: occurs depending on</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">occurs2</span><span class="p">(</span> <span class="n">occurs</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># format 1: fixed-length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;TIMES&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occurs_cruft</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">occurs_fixed_class</span><span class="p">(</span><span class="n">occurs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">occurs_cruft</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Soak up additional key and index sub-clauses.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;ASCENDING&quot;</span><span class="p">,</span><span class="s2">&quot;DESCENDING&quot;</span><span class="p">}:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;KEY&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;IS&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="c1"># get key data names</span>
    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;INDEXED&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;BY&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="c1"># get indexed data names</span>
    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">occurs2</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">lower</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse the [Occurs n TO] m Times Depending On name&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="n">upper</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="c1"># May be significant as a default size.</span>
    <span class="n">default_size</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;TIMES&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;DEPENDING&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;ON&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">occurs_cruft</span><span class="p">()</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">occurs_dependingon_class</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="n">default_size</span> <span class="p">)</span>
    <span class="c1">#raise stingray.cobol.defs.UnsupportedError( &quot;Occurs depending on&quot; )</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">redefines</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse a REDEFINES clause.&quot;&quot;&quot;</span>
    <span class="n">redef</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">redefines_class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">redef</span><span class="p">)</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">RENAMES</span></code> creates an alternative group-level name for some elementary items.
While it is considered bad practice, we still need to politely skip the syntax.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">renames</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an exception on a RENAMES clause.&quot;&quot;&quot;</span>
    <span class="n">ren1</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;THRU&quot;</span><span class="p">,</span><span class="s2">&quot;THROUGH&quot;</span><span class="p">}:</span>
        <span class="n">ren2</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s2">&quot;RENAMES clause found and ignored.&quot;</span> <span class="p">)</span>
    <span class="c1"># Alternative RENAMES</span>
    <span class="c1"># raise stingray.cobol.defs.UnsupportedError( &quot;Renames clause&quot; )</span>
</pre></div>
</div>
<p>There are two variations on the <code class="docutils literal notranslate"><span class="pre">SIGN</span></code> clause syntax.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sign1</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an exception on a SIGN clause.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;IS&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;LEADING&quot;</span><span class="p">,</span><span class="s2">&quot;TRAILING&quot;</span><span class="p">}:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sign2</span><span class="p">()</span>
    <span class="c1"># TODO: this may change the size to add a sign byte</span>
    <span class="k">raise</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">UnsupportedError</span><span class="p">(</span> <span class="s2">&quot;Sign clause&quot;</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">sign2</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an exception on a SIGN clause.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;SEPARATE&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;CHARACTER&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">UnsupportedError</span><span class="p">(</span> <span class="s2">&quot;Sign clause&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an exception on a SYNCHRONIZED clause.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;LEFT&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;RIGHT&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">UnsupportedError</span><span class="p">(</span> <span class="s2">&quot;Synchronized clause&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<p>There are two variations on the <code class="docutils literal notranslate"><span class="pre">USAGE</span></code> clause syntax.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">usage</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse a USAGE clause.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;IS&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="n">use</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage2</span><span class="p">(</span> <span class="n">use</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">usage2</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">use</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a correct Usage instance based on the USAGE clause.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use</span> <span class="o">==</span> <span class="s2">&quot;DISPLAY&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_class</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">use</span> <span class="o">==</span> <span class="s2">&quot;COMPUTATIONAL&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_class</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">use</span> <span class="o">==</span> <span class="s2">&quot;COMP&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_class</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">use</span> <span class="o">==</span> <span class="s2">&quot;COMPUTATIONAL-3&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp3_class</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">use</span> <span class="o">==</span> <span class="s2">&quot;COMP-3&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp3_class</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span> <span class="s2">&quot;Unknown usage clause </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">use</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>For 88-level items, the value clause can be quite long.
Otherwise, it’s just a single item. We have to absorb all quoted literal values.
It may be that we have to absorb all non-keyword values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">value</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse a VALUE clause.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;IS&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="n">lit</span><span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">),]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
        <span class="n">lit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lit</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.loader.RecordFactory.dde_iter">
<code class="descclassname">RecordFactory.</code><code class="descname">dde_iter</code><span class="sig-paren">(</span><em>lexer</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.RecordFactory.dde_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all DDE’s in the stream of tokens from the given lexer.
These DDE’s can then be assembled into an overall record
definition.</p>
<p>Note that we do not define special cases for 66, 77 or 88-level items.
These level numbers have special significance. For our purposes, however,
the numbers can be ignored.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dde_iter</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">lexer</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a single DDE from an entry of clauses.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">=</span> <span class="n">lexer</span>

    <span class="k">for</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">:</span>
        <span class="c1"># Start with the level.</span>
        <span class="n">level</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>

        <span class="c1"># Pick off a name, if present</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
            <span class="n">name</span><span class="o">=</span> <span class="s2">&quot;FILLER&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>

        <span class="c1"># Placeholder. The USAGE must be pushed down from parent.</span>
        <span class="c1"># At the very top, the 01 defaults to USAGE DISPLAY.</span>
        <span class="n">usage</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_usage_class</span><span class="p">()</span>
        <span class="c1"># Placeholder. The OCCURS is pushed down from the parent.</span>
        <span class="n">occurs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occurs_class</span><span class="p">()</span>

        <span class="c1"># Picture defines elementary vs. group level</span>
        <span class="n">pic</span><span class="o">=</span> <span class="kc">None</span>
        <span class="n">redefines</span><span class="o">=</span> <span class="kc">None</span> <span class="c1"># set to Redefines below or by addChild() to Group or Successor</span>

        <span class="c1"># Accumulate the relevant clauses, dropping noise words and irrelevant clauses.</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;BLANK&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blankWhenZero</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;EXTERNAL&quot;</span><span class="p">,</span><span class="s2">&quot;GLOBAL&quot;</span><span class="p">}:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;JUST&quot;</span><span class="p">,</span><span class="s2">&quot;JUSTIFIED&quot;</span><span class="p">}:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">justified</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;OCCURS&quot;</span><span class="p">:</span>
                <span class="n">occurs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occurs</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;PIC&quot;</span><span class="p">,</span><span class="s2">&quot;PICTURE&quot;</span><span class="p">}:</span>
                <span class="n">pic</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">picture</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;REDEFINES&quot;</span><span class="p">:</span>
                <span class="c1"># Must be first and no other clauses allowed.</span>
                <span class="c1"># Special case: simpler if 01 level ignores this clause.</span>
                <span class="n">clause</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redefines</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="s1">&#39;01&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span> <span class="s2">&quot;Ignoring top-level REDEFINES&quot;</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">redefines</span><span class="o">=</span> <span class="n">clause</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;RENAMES&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">renames</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;SIGN&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sign1</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;LEADING&quot;</span><span class="p">,</span><span class="s2">&quot;TRAILING&quot;</span><span class="p">}:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sign2</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;SYNCHRONIZED&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">synchronized</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;USAGE&quot;</span><span class="p">:</span>
                <span class="n">usage</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;VALUE&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Keyword USAGE is optional</span>
                    <span class="n">usage</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage2</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">SyntaxError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> unrecognized&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span>

        <span class="c1"># Create and yield the DDE</span>
        <span class="k">if</span> <span class="n">pic</span><span class="p">:</span>
            <span class="c1"># Parse the picture; update the USAGE clause with details.</span>
            <span class="n">sizeScalePrecision</span><span class="o">=</span> <span class="n">picture_parser</span><span class="p">(</span> <span class="n">pic</span> <span class="p">)</span>
            <span class="n">usage</span><span class="o">.</span><span class="n">setTypeInfo</span><span class="p">(</span><span class="n">sizeScalePrecision</span><span class="p">)</span>

            <span class="c1"># Build an elementary DDE</span>
            <span class="n">dde</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">DDE</span><span class="p">(</span>
                <span class="n">level</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">usage</span><span class="o">=</span><span class="n">usage</span><span class="p">,</span> <span class="n">occurs</span><span class="o">=</span><span class="n">occurs</span><span class="p">,</span> <span class="n">redefines</span><span class="o">=</span><span class="n">redefines</span><span class="p">,</span>
                <span class="n">pic</span><span class="o">=</span><span class="n">pic</span><span class="p">,</span> <span class="n">sizeScalePrecision</span><span class="o">=</span><span class="n">sizeScalePrecision</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Build a group-level DDE</span>
            <span class="n">dde</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">DDE</span><span class="p">(</span>
                <span class="n">level</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">usage</span><span class="o">=</span><span class="n">usage</span><span class="p">,</span> <span class="n">occurs</span><span class="o">=</span><span class="n">occurs</span><span class="p">,</span> <span class="n">redefines</span><span class="o">=</span><span class="n">redefines</span> <span class="p">)</span>

        <span class="k">yield</span> <span class="n">dde</span>
</pre></div>
</div>
<p>Note that some clauses (like <code class="docutils literal notranslate"><span class="pre">REDEFINES</span></code>) occupy a special place in COBOL syntax.
We’re not fastidious about enforcing COBOL semantic rules. Presumably the
source is proper COBOL and was actually used to create the source file.</p>
<dl class="method">
<dt id="cobol.loader.RecordFactory.makeRecord">
<code class="descclassname">RecordFactory.</code><code class="descname">makeRecord</code><span class="sig-paren">(</span><em>lexer</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.RecordFactory.makeRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>This overall is iterator
that yields the top-level records.</p>
<p>This depends on the <a class="reference internal" href="#cobol.loader.RecordFactory.dde_iter" title="cobol.loader.RecordFactory.dde_iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RecordFactory.dde_iter()</span></code></a> to get tokens and accumulates a proper
hierarchy of individual DDE instances.</p>
<p>This will yield a sequence of <code class="docutils literal notranslate"><span class="pre">01</span></code>-level records that are parsed.</p>
<p>The 77-level and 66-level items are not treated specially.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">makeRecord</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">lexer</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse an entire copybook block of text.&quot;&quot;&quot;</span>
    <span class="c1"># Parse the first DDE and establish the context stack.</span>
    <span class="n">ddeIter</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde_iter</span><span class="p">(</span> <span class="n">lexer</span> <span class="p">)</span>
    <span class="n">top</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ddeIter</span><span class="p">)</span>
    <span class="n">top</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">top</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="kc">None</span>
    <span class="n">top</span><span class="o">.</span><span class="n">allocation</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">Group</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">=</span> <span class="p">[</span><span class="n">top</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">dde</span> <span class="ow">in</span> <span class="n">ddeIter</span><span class="p">:</span>
        <span class="c1">#print( dde, &quot;:&quot;, self.context[-1] )</span>
        <span class="c1"># If a lower level number or same level, pop context</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="ow">and</span> <span class="n">dde</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Special case of multiple 01 levels.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span> <span class="s2">&quot;Multiple </span><span class="si">{0}</span><span class="s2"> levels&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">level</span><span class="p">)</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span> <span class="n">top</span> <span class="p">)</span>
            <span class="k">yield</span> <span class="n">top</span>
            <span class="c1"># Create a new top with this DDE.</span>
            <span class="n">top</span><span class="o">=</span> <span class="n">dde</span>
            <span class="n">top</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">top</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="kc">None</span>
            <span class="n">top</span><span class="o">.</span><span class="n">allocation</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">Group</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">=</span> <span class="p">[</span><span class="n">top</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># General case.</span>
            <span class="c1"># Make this DDE part of the parent DDE at the top of the context stack</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span> <span class="n">dde</span> <span class="p">)</span>
            <span class="c1"># Push this DDE onto the context stack</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">dde</span> <span class="p">)</span>
            <span class="c1"># Handle special case of &quot;88&quot; level children.</span>
            <span class="k">if</span> <span class="n">dde</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="s1">&#39;88&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">dde</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">picture</span><span class="p">,</span> <span class="s2">&quot;88 not under elementary item&quot;</span>
                <span class="n">dde</span><span class="o">.</span><span class="n">size</span><span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">size</span>
                <span class="n">dde</span><span class="o">.</span><span class="n">usage</span><span class="o">=</span> <span class="n">dde</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">usage</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span> <span class="n">top</span> <span class="p">)</span>
    <span class="k">yield</span> <span class="n">top</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.loader.RecordFactory.decorate">
<code class="descclassname">RecordFactory.</code><code class="descname">decorate</code><span class="sig-paren">(</span><em>top</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.RecordFactory.decorate" title="Permalink to this definition">¶</a></dt>
<dd><p>The final stages of compilation:</p>
<ul>
<li><p class="first">Resolve <code class="docutils literal notranslate"><span class="pre">REDEFINES</span></code> names using <a class="reference internal" href="cobol_defs.html#cobol.defs.resolver" title="cobol.defs.resolver"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.resolver()</span></code></a>.</p>
</li>
<li><p class="first">Push dimensionality down to each elementary item using <a class="reference internal" href="cobol_defs.html#cobol.defs.setDimensionality" title="cobol.defs.setDimensionality"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.setDimensionality()</span></code></a>.</p>
</li>
<li><p class="first">Work out size and offset, if possible. Use using <a class="reference internal" href="cobol_defs.html#cobol.defs.setSizeAndOffset" title="cobol.defs.setSizeAndOffset"><code class="xref py py-func docutils literal notranslate"><span class="pre">cobol.defs.setSizeAndOffset()</span></code></a>
This depends on the presence
of Occurs Depending On. If we can’t compute size and offset, it must be
computed as each row is read.
This is done automagically by a <a class="reference internal" href="sheet.html#sheet.LazyRow" title="sheet.LazyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">sheet.LazyRow</span></code></a> object.</p>
<p>Should we emit a warning? It’s not usually a mystery that the DDE involves
Occurs Depending On.</p>
</li>
</ul>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">top</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Post-processing steps: reference resolver,</span>
<span class="sd">    Then set Usage, dimensionality.</span>

<span class="sd">    For some record types (OCCURS DEPENDING ON)</span>
<span class="sd">    The size and offset have to be deferred.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">resolver</span><span class="p">(</span> <span class="n">top</span> <span class="p">)</span>
    <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">setDimensionality</span><span class="p">(</span> <span class="n">top</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">variably_located</span><span class="p">:</span>
        <span class="c1"># Cannot establish all offsets and total sizes.</span>
        <span class="k">pass</span> <span class="c1"># Log a warning?</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">defs</span><span class="o">.</span><span class="n">setSizeAndOffset</span><span class="p">(</span> <span class="n">top</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="cobol-schema-loader-class">
<h2>10.2.2.10. COBOL Schema Loader Class<a class="headerlink" href="#cobol-schema-loader-class" title="Permalink to this headline">¶</a></h2>
<p>Given a DDE, create a proper <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Schema</span></code></a> object which contains
proper <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Attribute</span></code></a> objects for each group and elementary item
in the DDE.</p>
<p>This schema, then, can be used with a COBOL workbook to fetch the rows and
columns.  Note that the conversions involved may be rather complex.</p>
<p>The <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Attribute</span></code></a> objects  are built by a function
that extracts relevant bits of goodness from a DDE.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>http://yuml.me/diagram/scruffy;/class/
#cobol_loader_final,
[COBOLSchemaLoader]-&gt;[Lexer],
[COBOLSchemaLoader]-&gt;[RecordFactory],
[RecordFactory]&lt;&gt;-[DDE],
[DDE]&lt;&gt;-[DDE].
</pre></div>
</div>
<img alt="_images/cobol_final.png" src="_images/cobol_final.png" />
<p>We have a number of supporting functions that make this work. The first two
will build the final Stingray schema from COBOL DDE definitions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make_attr_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;make_attr&quot;</span><span class="p">)</span>
<span class="n">make_schema_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;make_schema&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="cobol.loader.make_attr">
<code class="descclassname">cobol.loader.</code><code class="descname">make_attr</code><span class="sig-paren">(</span><em>aDDE</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.make_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a <a class="reference internal" href="cobol_defs.html#cobol.defs.DDE" title="cobol.defs.DDE"><code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.DDE</span></code></a> into an  <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.cobol.RepeatingAttribute</span></code>.
This will include a weakref to the DDE so that the source information (like parents and children)
is available. It will also build a weak reference from the original DDE to the resulting
attribute, allowing us to locate the schema associated with a DDE.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_attr</span><span class="p">(</span> <span class="n">aDDE</span> <span class="p">):</span>
    <span class="n">attr</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">RepeatingAttribute</span><span class="p">(</span>
        <span class="c1"># Essential features:</span>
        <span class="n">name</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
        <span class="n">create</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">usage</span><span class="o">.</span><span class="n">create_func</span><span class="p">,</span>

        <span class="c1"># COBOL extensions:</span>
        <span class="n">dde</span><span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">aDDE</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">aDDE</span><span class="o">.</span><span class="n">attribute</span><span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span> <span class="n">attr</span> <span class="p">)</span>
    <span class="n">make_attr_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span> <span class="s2">&quot;Attribute </span><span class="si">{0}</span><span class="s2"> &lt;=&gt; </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aDDE</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">attr</span>
</pre></div>
</div>
<dl class="function">
<dt id="cobol.loader.make_schema">
<code class="descclassname">cobol.loader.</code><code class="descname">make_schema</code><span class="sig-paren">(</span><em>dde_iter</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.make_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.Schema</span></code></a> – as a whole – is built by a function
that converts the individual DDE’s into attributes.</p>
<p>This may need to be extended in case other DDE names (i.e. paths)
are required in addition to the elementary names.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_schema</span><span class="p">(</span> <span class="n">dde_iter</span> <span class="p">):</span>
    <span class="n">schema</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">Schema</span><span class="p">(</span> <span class="n">dde</span><span class="o">=</span><span class="p">[]</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">dde_iter</span><span class="p">:</span>
        <span class="n">make_schema_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span> <span class="s2">&quot;Record </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">schema</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;dde&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">record</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">aDDE</span> <span class="ow">in</span> <span class="n">record</span><span class="p">:</span>
            <span class="n">attr</span><span class="o">=</span> <span class="n">make_attr</span><span class="p">(</span><span class="n">aDDE</span><span class="p">)</span>
            <span class="n">schema</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">attr</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">schema</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.loader.COBOLSchemaLoader">
<em class="property">class </em><code class="descclassname">cobol.loader.</code><code class="descname">COBOLSchemaLoader</code><a class="headerlink" href="#cobol.loader.COBOLSchemaLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>The overall schema loader process: parse and then build a schema.
This is consistent with the <a class="reference internal" href="schema_loader.html#schema.loader.ExternalSchemaLoader" title="schema.loader.ExternalSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">schema.loader.ExternalSchemaLoader</span></code></a>.</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">COBOLSchemaLoader</span><span class="p">(</span> <span class="n">stingray</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">ExternalSchemaLoader</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse a COBOL DDE and create a Schema.</span>
<span class="sd">    A subclass may define the lexer_class to customize</span>
<span class="sd">    parsing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lexer_class</span><span class="o">=</span> <span class="n">Lexer</span>
    <span class="n">record_factory_class</span><span class="o">=</span> <span class="n">RecordFactory</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">replacing</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer_class</span><span class="p">(</span> <span class="n">replacing</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_factory_class</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.loader.COBOLSchemaLoader.load">
<code class="descclassname">COBOLSchemaLoader.</code><code class="descname">load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.COBOLSchemaLoader.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the <a class="reference internal" href="#cobol.loader.RecordFactory.makeRecord" title="cobol.loader.RecordFactory.makeRecord"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RecordFactory.makeRecord()</span></code></a> method to iterate through
the top-level DDE’s. Use <a class="reference internal" href="#cobol.loader.make_schema" title="cobol.loader.make_schema"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_schema()</span></code></a> to build a single schema
from the DDE(s).</p>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="n">dde_iter</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">makeRecord</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">schema</span><span class="o">=</span> <span class="n">make_schema</span><span class="p">(</span> <span class="n">dde_iter</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">schema</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">replacing</span></code> keyword argument is a sequence of pairs: <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">('old','new'),</span> <span class="pre">...]</span></code>.
The old text is replaced with the new text.  This seems strange because it is.
COBOL allows replacement text to permit reuse without name clashes.</p>
<p>Note that we provide the “replacing” option to the underlying Lexer.
The lexical scanning includes any replacement text.</p>
</div>
<div class="section" id="top-level-schema-loader-functions">
<h2>10.2.2.11. Top-Level Schema Loader Functions<a class="headerlink" href="#top-level-schema-loader-functions" title="Permalink to this headline">¶</a></h2>
<p>The simplest use case is to create an instance of <a class="reference internal" href="#cobol.loader.COBOLSchemaLoader" title="cobol.loader.COBOLSchemaLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">COBOLSchemaLoader</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;sample/zipcty.cob&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cobol</span><span class="p">:</span>
    <span class="n">schema</span><span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">COBOLSchemaLoader</span><span class="p">(</span> <span class="n">cobol</span> <span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
</pre></div>
</div>
<p>In some cases, we need to subclass the SchemaLoader to change the lexer.
Here’s the example from <a class="reference internal" href="#extensions-and-special-cases">Extensions and Special Cases</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySchemaLoader</span><span class="p">(</span> <span class="n">cobol</span><span class="o">.</span><span class="n">COBOLSchemaLoader</span> <span class="p">):</span>
    <span class="n">lexer_class</span><span class="o">=</span> <span class="n">cobol</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">Lexer_Long_Lines</span>
</pre></div>
</div>
<p>In some cases, we want to see the intermediate COBOL record definitions.
In this case, we want to do something like the following function.</p>
<dl class="function">
<dt id="cobol.loader.COBOL_schema">
<code class="descclassname">cobol.loader.</code><code class="descname">COBOL_schema</code><span class="sig-paren">(</span><em>source</em>, <em>lexer_class=Lexer</em>, <em>replacing=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.COBOL_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will parse the COBOL copybook, returning a list of the parsed COBOL
01-level records as well as a final schema.</p>
<p>This is based on the (possibly false) assumption
that we’re making a single schema object from the definitions provided.</p>
<ul class="simple">
<li>In some cases, we want everything merged into a single schema.</li>
<li>In some edge cases, we want each 01-level to provide a distinct
schema object.</li>
</ul>
<p>We may need to revise this function because we need a different lexer.
We might have some awful formatting issue with the source that needs to be
tweaked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source</strong> – file-like object that is the open source file.</li>
<li><strong>lexer_class</strong> – Lexer to use. The default is <code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.load.Lexer</span></code>.</li>
<li><strong>replacing</strong> – replacing argument to provide to the lexer.
This is <code class="docutils literal notranslate"><span class="pre">None</span></code> by default.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2-tuple (dde_list, schema).
The first item is a list of 01-level <code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.def.DDE</span></code> objects.
The second item is a <code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.Schema</span></code> object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">COBOL_schema</span><span class="p">(</span> <span class="n">source</span><span class="p">,</span> <span class="n">lexer_class</span><span class="o">=</span><span class="n">Lexer</span><span class="p">,</span> <span class="n">replacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="p">):</span>
    <span class="n">lexer</span><span class="o">=</span> <span class="n">lexer_class</span><span class="p">(</span> <span class="n">replacing</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">=</span> <span class="n">RecordFactory</span><span class="p">()</span>
    <span class="n">dde_list</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">parser</span><span class="o">.</span><span class="n">makeRecord</span><span class="p">(</span> <span class="n">lexer</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">schema</span><span class="o">=</span> <span class="n">make_schema</span><span class="p">(</span> <span class="n">dde_list</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">dde_list</span><span class="p">,</span> <span class="n">schema</span>
</pre></div>
</div>
<dl class="function">
<dt id="cobol.loader.COBOL_schemata">
<code class="descclassname">cobol.loader.</code><code class="descname">COBOL_schemata</code><span class="sig-paren">(</span><em>source</em>, <em>replacing=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cobol.loader.COBOL_schemata" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will parse a COBOL copybook with multiple 01 level definitions,
returning two lists:</p>
<ul class="simple">
<li>a list of the parsed COBOL 01-level records, and</li>
<li>a list of final schemata, one for each 01-level definition.</li>
</ul>
<p>This is a peculiar extension in the rare case that we have multiple 01-levels
in a single file and we don’t want to (or can’t) use them as a single schema.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source</strong> – file-like object that is the open source file.</li>
<li><strong>lexer_class</strong> – Lexer to use. The default is <code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.load.Lexer</span></code>.</li>
<li><strong>replacing</strong> – replacing argument to provide to the lexer.
This is <code class="docutils literal notranslate"><span class="pre">None</span></code> by default.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2-tuple (dde_list, schema).
The first item is a list of 01-level <code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.def.DDE</span></code> objects.
The second item is list of <code class="xref py py-class docutils literal notranslate"><span class="pre">cobol.defs.Schema</span></code> objects, one for
each 01-level DDE.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">COBOL_schemata</span><span class="p">(</span> <span class="n">source</span><span class="p">,</span> <span class="n">replacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lexer_class</span><span class="o">=</span><span class="n">Lexer</span> <span class="p">):</span>
    <span class="n">lexer</span><span class="o">=</span> <span class="n">lexer_class</span><span class="p">(</span> <span class="n">replacing</span> <span class="p">)</span>
    <span class="n">parser</span><span class="o">=</span> <span class="n">RecordFactory</span><span class="p">()</span>
    <span class="n">dde_list</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">parser</span><span class="o">.</span><span class="n">makeRecord</span><span class="p">(</span> <span class="n">lexer</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">schema_list</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">make_schema</span><span class="p">(</span> <span class="n">dde</span> <span class="p">)</span> <span class="k">for</span> <span class="n">dde</span> <span class="ow">in</span> <span class="n">dde_list</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">dde_list</span><span class="p">,</span> <span class="n">schema_list</span>
</pre></div>
</div>
<p>This function gives us two API alternatives for parsing super-complex copybooks.</p>
<p>There’s a “Low-Level API” that looks like this:</p>
<p>There’s a “High-Level API” that looks like this:</p>
<p>When opening the workbook, one of the schema must be chosen as the “official” schema.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Stingray_belon1553_small.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="index.html">The Stingray Schema-Based File Reader, stingray</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">2. Design Considerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="package.html">3. The <code class="docutils literal notranslate"><span class="pre">stingray</span></code> Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="cell.html">4. Cell Module – Data Element Containers and Conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="sheet.html">5. Sheet Module – Sheet and Row Access</a></li>
<li class="toctree-l1"><a class="reference internal" href="schema.html">6. Schema Package – Schema and Attribute Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="schema_loader.html">7. Schema Loader Module – Load Embedded or External Schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="workbook/index.html">8. Workbook Package – Uniform Wrappers for Workbooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="iwork13.html">9. The “Other” Modules: snappy and protobuf</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="cobol.html">10. The COBOL Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer.html">11. The <strong>Stingray</strong> Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="demo/index.html">12. <strong>Stingray</strong> Demo Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">13. History</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing/index.html">14. Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">15. Stingray Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">16. Installation via <code class="docutils literal notranslate"><span class="pre">setup.py</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">17. Licensing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="cobol.html">10. The COBOL Package</a><ul>
      <li>Previous: <a href="cobol_init.html" title="previous chapter">10.2.1. COBOL Package – Extend Schema to Handle EBCDIC</a></li>
      <li>Next: <a href="cobol_defs.html" title="next chapter">10.2.3. COBOL Definitions Module – Handle COBOL DDE’s</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2013, S. Lott.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/cobol_loader.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>